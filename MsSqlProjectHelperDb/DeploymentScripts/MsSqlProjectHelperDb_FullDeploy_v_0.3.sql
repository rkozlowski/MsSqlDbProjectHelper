/*
Deployment script for MsSqlProjectHelperDb (v0.3)

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "MsSqlProjectHelperDb"
:setvar DefaultFilePrefix "MsSqlProjectHelperDb"
:setvar DefaultDataPath "C:\MsSQL\Data\"
:setvar DefaultLogPath "C:\MsSQL\Log\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
PRINT N'Creating Schema [Enum]...';


GO
CREATE SCHEMA [Enum]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Internal]...';


GO
CREATE SCHEMA [Internal]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [Project]...';


GO
CREATE SCHEMA [Project]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating User-Defined Table Type [Internal].[Variable]...';


GO
CREATE TYPE [Internal].[Variable] AS TABLE (
    [Id]    INT             IDENTITY (1, 1) NOT NULL,
    [Name]  NVARCHAR (128)  NOT NULL,
    [Value] NVARCHAR (4000) NULL,
    UNIQUE NONCLUSTERED ([Name] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating User-Defined Table Type [Internal].[EnumValue]...';


GO
CREATE TYPE [Internal].[EnumValue] AS TABLE (
    [Id]     INT            IDENTITY (1, 1) NOT NULL,
    [EnumId] INT            NOT NULL,
    [Name]   NVARCHAR (128) NOT NULL,
    [Value]  BIGINT         NOT NULL,
    UNIQUE NONCLUSTERED ([EnumId] ASC, [Value] ASC),
    UNIQUE NONCLUSTERED ([EnumId] ASC, [Name] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating User-Defined Table Type [Internal].[Enum]...';


GO
CREATE TYPE [Internal].[Enum] AS TABLE (
    [Id]          INT            IDENTITY (1, 1) NOT NULL,
    [Schema]      NVARCHAR (128) NOT NULL,
    [Table]       NVARCHAR (128) NOT NULL,
    [EnumName]    NVARCHAR (256) NOT NULL,
    [NameColumn]  NVARCHAR (128) NOT NULL,
    [ValueColumn] NVARCHAR (128) NOT NULL,
    UNIQUE NONCLUSTERED ([Schema] ASC, [Table] ASC),
    UNIQUE NONCLUSTERED ([EnumName] ASC),
    PRIMARY KEY CLUSTERED ([Id] ASC));


GO
PRINT N'Creating Table [Enum].[TemplateType]...';


GO
CREATE TABLE [Enum].[TemplateType] (
    [Id]   TINYINT      NOT NULL,
    [Name] VARCHAR (50) NOT NULL,
    CONSTRAINT [PK_Enum_TemplateType] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[TemplateType].[UX_Enum_TemplateType_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_TemplateType_Name]
    ON [Enum].[TemplateType]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[Language]...';


GO
CREATE TABLE [Enum].[Language] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_Language] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[Language].[UX_Enum_Language_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_Language_Name]
    ON [Enum].[Language]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[ClassAccess]...';


GO
CREATE TABLE [Enum].[ClassAccess] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_ClassAccess] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[ClassAccess].[UX_Enum_ClassAccess_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_ClassAccess_Name]
    ON [Enum].[ClassAccess]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[Casing]...';


GO
CREATE TABLE [Enum].[Casing] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (200) NOT NULL,
    CONSTRAINT [PK_Enum_Casing] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[Casing].[UX_Enum_Casing_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_Casing_Name]
    ON [Enum].[Casing]([Name] ASC);


GO
PRINT N'Creating Table [Enum].[ParamEnumMapping]...';


GO
CREATE TABLE [Enum].[ParamEnumMapping] (
    [Id]   TINYINT       NOT NULL,
    [Name] VARCHAR (100) NOT NULL,
    CONSTRAINT [PK_Enum_ParamEnumMapping] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [Enum].[ParamEnumMapping].[UX_Enum_ParamEnumMapping_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Enum_ParamEnumMapping_Name]
    ON [Enum].[ParamEnumMapping]([Name] ASC);


GO
PRINT N'Creating Table [dbo].[DataTypeMap]...';


GO
CREATE TABLE [dbo].[DataTypeMap] (
    [Id]              SMALLINT       IDENTITY (1, 1) NOT NULL,
    [LanguageId]      TINYINT        NOT NULL,
    [SqlType]         NVARCHAR (128) NOT NULL,
    [NativeType]      VARCHAR (200)  NOT NULL,
    [SqlDbType]       VARCHAR (200)  NULL,
    [DbType]          VARCHAR (200)  NULL,
    [IsNullable]      BIT            NOT NULL,
    [SizeNeeded]      BIT            NOT NULL,
    [PrecisionNeeded] BIT            NOT NULL,
    [ScaleNeeded]     BIT            NOT NULL,
    CONSTRAINT [PK_DataTypeMap] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[DataTypeMap].[UX_DataTypeMap_LanguageId_SqlType]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_DataTypeMap_LanguageId_SqlType]
    ON [dbo].[DataTypeMap]([LanguageId] ASC, [SqlType] ASC);


GO
PRINT N'Creating Table [dbo].[ErrorLog]...';


GO
CREATE TABLE [dbo].[ErrorLog] (
    [Id]             INT             IDENTITY (1, 1) NOT NULL,
    [ErrorTime]      DATETIME2 (2)   NOT NULL,
    [UserName]       [sysname]       NOT NULL,
    [ErrorNumber]    INT             NOT NULL,
    [ErrorSeverity]  INT             NULL,
    [ErrorState]     INT             NULL,
    [ErrorProcedure] NVARCHAR (126)  NULL,
    [ErrorLine]      INT             NULL,
    [ErrorMessage]   NVARCHAR (4000) NOT NULL,
    CONSTRAINT [PK_ErrorLog_ErrorLogID] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Table [dbo].[Project]...';


GO
CREATE TABLE [dbo].[Project] (
    [Id]                            SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Name]                          NVARCHAR (200) NOT NULL,
    [NamespaceName]                 VARCHAR (100)  NOT NULL,
    [ClassName]                     VARCHAR (100)  NOT NULL,
    [ClassAccessId]                 TINYINT        NOT NULL,
    [EnumSchema]                    NVARCHAR (128) NULL,
    [StoredProcSchema]              NVARCHAR (128) NULL,
    [GenerateAllStoredProcWrappers] BIT            NOT NULL,
    [GenerateAllEnumWrappers]       BIT            NOT NULL,
    [LanguageId]                    TINYINT        NOT NULL,
    [ParamEnumMappingId]            TINYINT        NOT NULL,
    [MapResultSetEnums]             BIT            NOT NULL,
    [GenerateStaticClass]           BIT            NOT NULL,
    [TreatOutputParamAsInputOutput] BIT            NOT NULL,
    [DefaultDatabase]               NVARCHAR (128) NULL,
    CONSTRAINT [PK_Project] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[Project].[UX_Project_Name]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Project_Name]
    ON [dbo].[Project]([Name] ASC);


GO
PRINT N'Creating Table [dbo].[Template]...';


GO
CREATE TABLE [dbo].[Template] (
    [Id]         SMALLINT        IDENTITY (1, 1) NOT NULL,
    [LanguageId] TINYINT         NOT NULL,
    [TypeId]     TINYINT         NOT NULL,
    [Template]   NVARCHAR (4000) NOT NULL,
    CONSTRAINT [PK_Template] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[Template].[UX_Template_LanguageId_TypeId]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Template_LanguageId_TypeId]
    ON [dbo].[Template]([LanguageId] ASC, [TypeId] ASC);


GO
PRINT N'Creating Table [dbo].[Version]...';


GO
CREATE TABLE [dbo].[Version] (
    [Id]          SMALLINT       IDENTITY (1, 1) NOT NULL,
    [Version]     VARCHAR (50)   NOT NULL,
    [Description] NVARCHAR (500) NOT NULL,
    [Created]     DATETIME2 (2)  NOT NULL,
    CONSTRAINT [PK_Version] PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating Index [dbo].[Version].[UX_Version_Version]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UX_Version_Version]
    ON [dbo].[Version]([Version] ASC);


GO
PRINT N'Creating Default Constraint [dbo].[DF_DataTypeMap_IsNullable]...';


GO
ALTER TABLE [dbo].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_IsNullable] DEFAULT ((1)) FOR [IsNullable];


GO
PRINT N'Creating Default Constraint [dbo].[DF_DataTypeMap_SizeNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_SizeNeeded] DEFAULT ((0)) FOR [SizeNeeded];


GO
PRINT N'Creating Default Constraint [dbo].[DF_DataTypeMap_PrecisionNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_PrecisionNeeded] DEFAULT ((0)) FOR [PrecisionNeeded];


GO
PRINT N'Creating Default Constraint [dbo].[DF_DataTypeMap_ScaleNeeded]...';


GO
ALTER TABLE [dbo].[DataTypeMap]
    ADD CONSTRAINT [DF_DataTypeMap_ScaleNeeded] DEFAULT ((0)) FOR [ScaleNeeded];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ErrorLog_ErrorTime]...';


GO
ALTER TABLE [dbo].[ErrorLog]
    ADD CONSTRAINT [DF_ErrorLog_ErrorTime] DEFAULT (sysutcdatetime()) FOR [ErrorTime];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_GenStoredProcWrappersForAll]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_GenStoredProcWrappersForAll] DEFAULT ((1)) FOR [GenerateAllStoredProcWrappers];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_GenEnumWrappersForAllTablesInEnumSchema]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_GenEnumWrappersForAllTablesInEnumSchema] DEFAULT ((1)) FOR [GenerateAllEnumWrappers];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_ParamEnumMapping]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_ParamEnumMapping] DEFAULT ((1)) FOR [ParamEnumMappingId];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_MapResultSetEnums]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_MapResultSetEnums] DEFAULT ((0)) FOR [MapResultSetEnums];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_GenerateStaticClass]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_GenerateStaticClass] DEFAULT ((0)) FOR [GenerateStaticClass];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Project_TreatOutputParamAsInputOutput]...';


GO
ALTER TABLE [dbo].[Project]
    ADD CONSTRAINT [DF_Project_TreatOutputParamAsInputOutput] DEFAULT ((1)) FOR [TreatOutputParamAsInputOutput];


GO
PRINT N'Creating Default Constraint [dbo].[DF_Version_Created]...';


GO
ALTER TABLE [dbo].[Version]
    ADD CONSTRAINT [DF_Version_Created] DEFAULT (sysutcdatetime()) FOR [Created];


GO
PRINT N'Creating Foreign Key [dbo].[FK_DataTypeMap_Language]...';


GO
ALTER TABLE [dbo].[DataTypeMap] WITH NOCHECK
    ADD CONSTRAINT [FK_DataTypeMap_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Project_ClassAccess]...';


GO
ALTER TABLE [dbo].[Project] WITH NOCHECK
    ADD CONSTRAINT [FK_Project_ClassAccess] FOREIGN KEY ([ClassAccessId]) REFERENCES [Enum].[ClassAccess] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Project_Language]...';


GO
ALTER TABLE [dbo].[Project] WITH NOCHECK
    ADD CONSTRAINT [FK_Project_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Template_Language]...';


GO
ALTER TABLE [dbo].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_Language] FOREIGN KEY ([LanguageId]) REFERENCES [Enum].[Language] ([Id]);


GO
PRINT N'Creating Foreign Key [dbo].[FK_Template_TemplateType]...';


GO
ALTER TABLE [dbo].[Template] WITH NOCHECK
    ADD CONSTRAINT [FK_Template_TemplateType] FOREIGN KEY ([TypeId]) REFERENCES [Enum].[TemplateType] ([Id]);


GO
PRINT N'Creating Function [Internal].[GetName]...';


GO
CREATE FUNCTION [Internal].[GetName]
(	
	@langId TINYINT,
	@name NVARCHAR(128),
	@schema NVARCHAR(128)
)
RETURNS NVARCHAR(200)
AS
BEGIN
	
	DECLARE @result NVARCHAR(200) = '';
	
	DECLARE @temp VARCHAR(128) = CAST(@name AS VARCHAR(128));

	DECLARE @l INT = LEN(@temp);

	DECLARE @i INT = 0;
	
	WHILE @i < @l
	BEGIN
		SET @i += 1;
		DECLARE @c CHAR(1) = SUBSTRING(@temp, @i, 1);
		IF @c LIKE '[A-Za-z0-9]'
		BEGIN
			SET @result += @c;
		END
	END

	RETURN ISNULL(NULLIF(@result, ''), '_');
END
GO
PRINT N'Creating Function [Internal].[RemoveFromEnd]...';


GO

CREATE FUNCTION [Internal].[RemoveFromEnd]
(		
	@text NVARCHAR(500),
	@end NVARCHAR(128)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = @text;
	
	DECLARE @tl INT = LEN(@text);
	DECLARE @el INT = LEN(@end);

	IF (@el > 0 AND @tl >= @el AND RIGHT(@text, @el)=@end)
	BEGIN
		SET @result = LEFT(@text, @tl - @el);
	END
	

	RETURN @result;
END
GO
PRINT N'Creating Function [Internal].[RemoveFromStart]...';


GO

CREATE FUNCTION [Internal].[RemoveFromStart]
(		
	@text NVARCHAR(500),
	@start NVARCHAR(128)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = @text;
	
	DECLARE @tl INT = LEN(@text);
	DECLARE @sl INT = LEN(@start);

	IF (@sl > 0 AND @tl >= @sl AND LEFT(@text, @sl)=@start)
	BEGIN
		SET @result = RIGHT(@text, @tl - @sl);
	END
	

	RETURN @result;
END
GO
PRINT N'Creating Function [dbo].[DelimitedSplitN4K]...';


GO
 CREATE FUNCTION [dbo].[DelimitedSplitN4K]
/**********************************************************************************************************************
 Purpose:
 Split a given string at a given delimiter and return a list of the split elements (items).

 Notes:
 1.  Leading a trailing delimiters are treated as if an empty string element were present.
 2.  Consecutive delimiters are treated as if an empty string element were present between them.
 3.  Except when spaces are used as a delimiter, all spaces present in each element are preserved.

 Returns:
 iTVF containing the following:
 ItemNumber = Element position of Item as a BIGINT (not converted to INT to eliminate a CAST)
 Item       = Element value as a NVARCHAR(4000)

 CROSS APPLY Usage Examples and Tests:
--=====================================================================================================================
-- TEST 1:
-- This tests for various possible conditions in a string using a comma as the delimiter.  The expected results are
-- laid out in the comments
--=====================================================================================================================
--===== Conditionally drop the test tables to make reruns easier for testing.
     -- (this is NOT a part of the solution)
     IF OBJECT_ID('tempdb..#JBMTest') IS NOT NULL DROP TABLE #JBMTest
;
--===== Create and populate a test table on the fly (this is NOT a part of the solution).
     -- In the following comments, "b" is a blank and "E" is an element in the left to right order.
     -- Double Quotes are used to encapsulate the output of "Item" so that you can see that all blanks
     -- are preserved no matter where they may appear.
 SELECT *
   INTO #JBMTest
   FROM (                                               --# & type of Return Row(s)
         SELECT  0, NULL                       UNION ALL --1 NULL
         SELECT  1, SPACE(0)                   UNION ALL --1 b (Empty String)
         SELECT  2, SPACE(1)                   UNION ALL --1 b (1 space)
         SELECT  3, SPACE(5)                   UNION ALL --1 b (5 spaces)
         SELECT  4, N','                       UNION ALL --2 b b (both are empty strings)
         SELECT  5, N'55555'                   UNION ALL --1 E
         SELECT  6, N',55555'                  UNION ALL --2 b E
         SELECT  7, N',55555,'                 UNION ALL --3 b E b
         SELECT  8, N'55555,'                  UNION ALL --2 b B
         SELECT  9, N'55555,1'                 UNION ALL --2 E E
         SELECT 10, N'1,55555'                 UNION ALL --2 E E
         SELECT 11, N'55555,4444,333,22,1'     UNION ALL --5 E E E E E 
         SELECT 12, N'55555,4444,,333,22,1'    UNION ALL --6 E E b E E E
         SELECT 13, N',55555,4444,,333,22,1,'  UNION ALL --8 b E E b E E E b
         SELECT 14, N',55555,4444,,,333,22,1,' UNION ALL --9 b E E b b E E E b
         SELECT 15, N' 4444,55555 '            UNION ALL --2 E (w/Leading Space) E (w/Trailing Space)
         SELECT 16, N'This,is,a,test.'                   --E E E E
        ) d (SomeID, SomeValue)
;
--===== Split the CSV column for the whole table using CROSS APPLY (this is the solution)
 SELECT test.SomeID, test.SomeValue, split.ItemNumber, Item = QUOTENAME(split.Item,'"')
   FROM #JBMTest test
  CROSS APPLY dbo.DelimitedSplitN4K(test.SomeValue,',') split
;
--=====================================================================================================================
-- TEST 2:
-- This tests for various "alpha" splits and COLLATION using all ASCII characters from 0 to 255 as a delimiter against
-- a given string.  Note that not all of the delimiters will be visible and some will show up as tiny squares because
-- they are "control" characters.  More specifically, this test will show you what happens to various non-accented 
-- letters for your given collation depending on the delimiter you chose.
--=====================================================================================================================
WITH 
cteBuildAllCharacters (String,Delimiter) AS 
(
 SELECT TOP 256 
        N'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
        NCHAR(ROW_NUMBER() OVER (ORDER BY (SELECT NULL))-1)
   FROM master.sys.all_columns
)
 SELECT ASCII_Value = ASCII(c.Delimiter), c.Delimiter, split.ItemNumber, Item = QUOTENAME(split.Item,'"')
   FROM cteBuildAllCharacters c
  CROSS APPLY dbo.DelimitedSplitN4K(c.String,c.Delimiter) split
  ORDER BY ASCII_Value, split.ItemNumber
;
-----------------------------------------------------------------------------------------------------------------------
 Other Notes:
 1. Optimized for NVARCHAR(4000) or less.  No testing or error reporting for truncation at 8000 characters is done.
 2. Optimized for single character delimiter.  Multi-character delimiters should be resolvedexternally from this 
    function.
 3. Optimized for use with CROSS APPLY.
 4. Does not "trim" elements just in case leading or trailing blanks are intended.
 5. If you don't know how a Tally table can be used to replace loops, please see the following...
    http://www.sqlservercentral.com/articles/T-SQL/62867/
 6. Changing this function to use NVARCHAR(MAX) will cause it to run twice as slow.  It's just the nature of 
    VARCHAR(MAX) whether it fits in-row or not.
 7. Multi-machine testing for the method of using UNPIVOT instead of 10 SELECT/UNION ALLs shows that the UNPIVOT method
    is quite machine dependent and can slow things down quite a bit.
-----------------------------------------------------------------------------------------------------------------------
 Credits:
 This code is the product of many people's efforts including but not limited to the following:
 cteTally concept originally by Iztek Ben Gan and "decimalized" by Lynn Pettis (and others) for a bit of extra speed
 and finally redacted by Jeff Moden for a different slant on readability and compactness. Hat's off to Paul White for
 his simple explanations of CROSS APPLY and for his detailed testing efforts. Last but not least, thanks to
 Ron "BitBucket" McCullough and Wayne Sheffield for their extreme performance testing across multiple machines and
 versions of SQL Server.  The latest improvement brought an additional 15-20% improvement over Rev 05.  Special thanks
 to "Nadrek" and "peter-757102" (aka Peter de Heer) for bringing such improvements to light.  Nadrek's original
 improvement brought about a 10% performance gain and Peter followed that up with the content of Rev 07.  

 I also thank whoever wrote the first article I ever saw on "numbers tables" which is located at the following URL
 and to Adam Machanic for leading me to it many years ago.
 http://sqlserver2000.databases.aspfaq.com/why-should-i-consider-using-an-auxiliary-numbers-table.html
-----------------------------------------------------------------------------------------------------------------------
 Revision History:
 Rev 00 - 20 Jan 2010 - Concept for inline cteTally: Lynn Pettis and others.
                        Redaction/Implementation: Jeff Moden 
        - Base 10 redaction and reduction for CTE.  (Total rewrite)

 Rev 01 - 13 Mar 2010 - Jeff Moden
        - Removed one additional concatenation and one subtraction from the SUBSTRING in the SELECT List for that tiny
          bit of extra speed.

 Rev 02 - 14 Apr 2010 - Jeff Moden
        - No code changes.  Added CROSS APPLY usage example to the header, some additional credits, and extra 
          documentation.

 Rev 03 - 18 Apr 2010 - Jeff Moden
        - No code changes.  Added notes 7, 8, and 9 about certain "optimizations" that don't actually work for this
          type of function.

 Rev 04 - 29 Jun 2010 - Jeff Moden
        - Added WITH SCHEMABINDING thanks to a note by Paul White.  This prevents an unnecessary "Table Spool" when the
          function is used in an UPDATE statement even though the function makes no external references.

 Rev 05 - 02 Apr 2011 - Jeff Moden
        - Rewritten for extreme performance improvement especially for larger strings approaching the 8K boundary and
          for strings that have wider elements.  The redaction of this code involved removing ALL concatenation of 
          delimiters, optimization of the maximum "N" value by using TOP instead of including it in the WHERE clause,
          and the reduction of all previous calculations (thanks to the switch to a "zero based" cteTally) to just one 
          instance of one add and one instance of a subtract. The length calculation for the final element (not 
          followed by a delimiter) in the string to be split has been greatly simplified by using the ISNULL/NULLIF 
          combination to determine when the CHARINDEX returned a 0 which indicates there are no more delimiters to be
          had or to start with. Depending on the width of the elements, this code is between 4 and 8 times faster on a
          single CPU box than the original code especially near the 8K boundary.
        - Modified comments to include more sanity checks on the usage example, etc.
        - Removed "other" notes 8 and 9 as they were no longer applicable.

 Rev 06 - 12 Apr 2011 - Jeff Moden
        - Based on a suggestion by Ron "Bitbucket" McCullough, additional test rows were added to the sample code and
          the code was changed to encapsulate the output in pipes so that spaces and empty strings could be perceived 
          in the output.  The first "Notes" section was added.  Finally, an extra test was added to the comments above.

 Rev 07 - 06 May 2011 - Peter de Heer, a further 15-20% performance enhancement has been discovered and incorporated 
          into this code which also eliminated the need for a "zero" position in the cteTally table. 
**********************************************************************************************************************/
--===== Define I/O parameters
        (@pString NVARCHAR(4000), @pDelimiter NCHAR(1))
RETURNS TABLE WITH SCHEMABINDING AS
 RETURN
--===== "Inline" CTE Driven "Tally Table" produces values from 0 up to 10,000...
     -- enough to cover NVARCHAR(4000)
  WITH E1(N) AS (
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL 
                 SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1 UNION ALL SELECT 1
                ),                          --10E+1 or 10 rows
       E2(N) AS (SELECT 1 FROM E1 a, E1 b), --10E+2 or 100 rows
       E4(N) AS (SELECT 1 FROM E2 a, E2 b), --10E+4 or 10,000 rows max
 cteTally(N) AS (--==== This provides the "base" CTE and limits the number of rows right up front
                     -- for both a performance gain and prevention of accidental "overruns"
                 SELECT TOP (ISNULL(DATALENGTH(@pString)/2,0)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E4
                ),
cteStart(N1) AS (--==== This returns N+1 (starting position of each "element" just once for each delimiter)
                 SELECT 1 UNION ALL 
                 SELECT t.N+1 FROM cteTally t WHERE SUBSTRING(@pString,t.N,1) = @pDelimiter
                ),
cteLen(N1,L1) AS(--==== Return start and length (for use in substring)
                 SELECT s.N1,
                        ISNULL(NULLIF(CHARINDEX(@pDelimiter,@pString,s.N1),0)-s.N1,4000)
                   FROM cteStart s
                )
--===== Do the actual split. The ISNULL/NULLIF combo handles the length for the final element when no delimiter is found.
 SELECT ItemNumber = ROW_NUMBER() OVER(ORDER BY l.N1),
        Item       = SUBSTRING(@pString, l.N1, l.L1)
   FROM cteLen l
;
GO
PRINT N'Creating Function [Internal].[ProcessTemplate]...';


GO

CREATE FUNCTION [Internal].[ProcessTemplate]
(
	@template NVARCHAR(4000),
	@vars [Internal].[Variable] READONLY	
)
RETURNS 
@result TABLE 
(
	[Id] INT NOT NULL IDENTITY(1,1) PRIMARY KEY,
	[Text] NVARCHAR(4000)
)
AS
BEGIN
	DECLARE @id INT = (SELECT MIN([Id]) FROM @vars);
	WHILE @id IS NOT NULL
	BEGIN
		SELECT @template = REPLACE(@template, N'@{' + [Name] + N'}', ISNULL([Value], N''))
		FROM @vars
		WHERE [Id]=@id;
		SELECT @id=MIN([Id]) FROM @vars
		WHERE [Id]>@id;
	END
	INSERT INTO @result ([Text])
	SELECT d.[Item]
	FROM [dbo].[DelimitedSplitN4K](@template, CHAR(10)) d
	ORDER BY d.[ItemNumber];
	UPDATE @result
	SET [Text]=REPLACE([Text], CHAR(13), '');
	RETURN 
END
GO
PRINT N'Creating Function [Internal].[SplitName]...';


GO
CREATE FUNCTION [Internal].[SplitName]
(
	@name NVARCHAR(4000)
)
RETURNS 
@result TABLE 
(
	[ItemNumber] SMALLINT,
	[Item] NVARCHAR(4000)
)
AS
BEGIN
	DECLARE @l INT = LEN(@name);

	DECLARE @CT_START TINYINT = 0;
	DECLARE @CT_SEPARATOR TINYINT = 1;
	DECLARE @CT_DIGIT TINYINT = 2;
	DECLARE @CT_LOWER_LETTER TINYINT = 3;
	DECLARE @CT_UPPER_LETTER TINYINT = 4;

	DECLARE @IT_NONE TINYINT = 0;
	DECLARE @IT_UPPER TINYINT = 1;
	DECLARE @IT_LOWER TINYINT = 2;
	DECLARE @IT_PASCAL TINYINT = 3;
	DECLARE @IT_UPPER_DIGIT TINYINT = 4;
	
	DECLARE @item NVARCHAR(4000) = NULL;
	DECLARE @itemNo SMALLINT = 1;
	DECLARE @i INT = 0;
	DECLARE @pc CHAR(1) = NULL;
	DECLARE @c CHAR(1) = NULL;
	DECLARE @pct TINYINT = @CT_START;
	DECLARE @ct TINYINT;
	DECLARE @il INT = 0;
	DECLARE @it TINYINT = @IT_NONE;

	WHILE @i < @l
	BEGIN
		SET @i += 1;
		SET @c = SUBSTRING(@name, @i, 1);
		IF @c LIKE '[A-Z]' COLLATE Latin1_General_100_BIN2
		BEGIN
			SET @ct = @CT_UPPER_LETTER;
		END
		ELSE IF @c LIKE '[a-z]' COLLATE Latin1_General_100_BIN2
		BEGIN
			SET @ct = @CT_LOWER_LETTER;
		END
		ELSE IF @c LIKE '[0-9]'
		BEGIN
			SET @ct = @CT_DIGIT;
		END
		ELSE
		BEGIN
			SET @ct = @CT_SEPARATOR;
		END

		IF @ct = @CT_SEPARATOR
		BEGIN
			IF @il > 0
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = NULL;
				SET @il = 0;
				SET @it = @IT_NONE;
			END
		END
		ELSE IF @ct = @CT_DIGIT
		BEGIN
			IF @it <> @IT_NONE
			BEGIN
				IF @it = @IT_UPPER
				BEGIN
					SET @it = @IT_UPPER_DIGIT
				END
				SET @item += @c;
				SET @il += 1;
			END
		END
		ELSE IF @ct = @CT_UPPER_LETTER
		BEGIN
			IF @it = @IT_NONE
			BEGIN
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_UPPER;
			END
			ELSE IF @it = @IT_UPPER
			BEGIN
				SET @item += @c;
				SET @il += 1;
			END
			ELSE -- @IT_LOWER, @IT_PASCAL, @IT_UPPER_DIGIT
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_UPPER;
			END 
		END
		ELSE IF @ct = @CT_LOWER_LETTER
		BEGIN
			IF @it = @IT_NONE
			BEGIN
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_LOWER;
			END
			ELSE IF @it = @IT_UPPER
			BEGIN
				IF @il > 1
				BEGIN
					INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, LEFT(@item, @il - 1));
					SET @itemNo += 1;
					SET @item = RIGHT(@item, 1);
					SET @il = 1;
				END
				
				SET @item += @c;
				SET @il += 1;
				SET @it = @IT_PASCAL;
			END
			ELSE IF @it = @IT_UPPER_DIGIT
			BEGIN
				INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
				SET @itemNo += 1;
				SET @item = @c;
				SET @il = 1;
				SET @it = @IT_LOWER;
			END
			ELSE -- @IT_LOWER, @IT_PASCAL
			BEGIN				
				SET @item += @c;
				SET @il += 1;				
			END
		END
	END;
	IF @item IS NOT NULL
	BEGIN
		INSERT INTO @result ([ItemNumber], [Item]) VALUES (@itemNo, @item);
	END
	RETURN;
END
GO
PRINT N'Creating Function [Internal].[GetCaseName]...';


GO

CREATE FUNCTION [Internal].[GetCaseName]
(	
	@caseId TINYINT,
	@name NVARCHAR(200),
	@schema NVARCHAR(200)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	
	DECLARE @result NVARCHAR(500) = '';

	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

	IF LTRIM(ISNULL(@schema, '')) NOT IN (N'dbo', N'sys', N'')
	BEGIN
		SET @name = @schema + N'.' + @name;
	END

	DECLARE @pfx NVARCHAR(1) = CASE WHEN @caseId=@C_UNDERSCORE_CAMEL_CASE THEN N'_' ELSE N'' END;
	DECLARE @sep NVARCHAR(1) = CASE WHEN @caseId IN (@C_SNAKE_CASE, @C_UPPER_SNAKE_CASE) THEN N'_' ELSE N'' END;

	SELECT @result=@pfx+STRING_AGG(
		CASE 
		WHEN @caseId=@C_PASCAL_CASE OR ([ItemNumber]>1 AND @caseId IN (@C_CAMEL_CASE, @C_UNDERSCORE_CAMEL_CASE)) 
			THEN UPPER(LEFT([Item], 1)) + LOWER(RIGHT([Item], LEN([Item]) - 1)) 
		WHEN @caseId IN (@C_SNAKE_CASE, @C_CAMEL_CASE, @C_UNDERSCORE_CAMEL_CASE) THEN LOWER([Item])
		ELSE Upper([Item])
		END
		, @sep
	) WITHIN GROUP (ORDER BY [ItemNumber] ASC)	
	FROM [Internal].[SplitName](@name);
	
	RETURN @result;
END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcParams]...';


GO


CREATE PROCEDURE [Internal].[GetStoredProcParams]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @PEM_EXPLICIT_ONLY TINYINT = 1;
	DECLARE @PEM_ENUM_NAME TINYINT = 2;
	DECLARE @PEM_ENUM_NAME_WITH_ID TINYINT = 3;
	DECLARE @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID TINYINT = 4;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	DECLARE @pemId TINYINT;

	SELECT @pemId=[ParamEnumMappingId]      
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @pemId IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END
	

	SELECT @spSchema=[Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	IF @spSchema IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@spId) + N' [StoredProcId], p.[parameter_id] [ParamId], p.[name] [Name], t.[name] [SqlType], SCHEMA_NAME(t.schema_id) [SqlTypeSchema], '
	SET @query += N'p.[max_length] [MaxLen], p.[precision] [Precision], p.[scale] [Scale], p.[is_output] [IsOutput], p.[is_readonly] [IsReadOnly], '
	SET @query += N't.[is_user_defined] [IsTypeUserDefined], t.[is_table_type] [IsTableType] '
	SET @query += N'FROM sys.procedures sp '
	SET @query += N'JOIN sys.parameters p ON p.[object_id]=sp.[object_id] '
	SET @query += N'JOIN sys.types t ON p.[user_type_id]=t.[user_type_id] '
	SET @query += N'WHERE sp.[Type]=''P'' '
	SET @query += N'AND SCHEMA_NAME(sp.schema_id)=' + QUOTENAME(@spSchema, N'''') + N' AND sp.[name]=' + QUOTENAME(@spName, N'''') + N' '
	SET @query += N'ORDER BY p.[parameter_id] '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #StoredProcParam ([StoredProcId], [ParamId], [Name], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [IsOutput], [IsReadOnly], [IsTypeUserDefined], [IsTableType])
	EXEC(@query);

	IF (@pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID))
	BEGIN
		UPDATE spp
		SET spp.[EnumId]=e.[Id]
		FROM #StoredProcParam spp
		JOIN #Enum e ON spp.[SqlType]=e.[ValueType] 
		AND ((e.[EnumName]=[Internal].[RemoveFromStart](spp.[Name], N'@') AND @pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)) 
		OR (spp.[Name] LIKE N'%Id' AND e.[EnumName]=[Internal].[RemoveFromEnd]([Internal].[RemoveFromStart](spp.[Name], N'@'), N'Id') AND @pemId IN (@PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)))
	END
	SET @rc=@RC_OK;
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcedures]...';


GO

CREATE PROCEDURE [Internal].[GetStoredProcedures]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @generateAll BIT;

	SELECT @spSchema = [StoredProcSchema], @generateAll=[GenerateAllStoredProcWrappers]
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @spSchema IS NULL OR @generateAll<>1
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT SCHEMA_NAME(p.schema_id) [Schema], p.[name] [Name] '
	SET @query += N'FROM sys.procedures p '	
	SET @query += N'WHERE p.[Type]=''P''  '
	SET @query += N'AND SCHEMA_NAME(p.schema_id)=''' + @spSchema + N''' '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #StoredProc ([Schema], [Name])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GenerateEnumCode]...';


GO


CREATE PROCEDURE [Internal].[GenerateEnumCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_ENUM_START TINYINT = 3;
	DECLARE @TT_ENUM_END TINYINT = 4;
	DECLARE @TT_ENUM_ENTRY TINYINT = 5;

	DECLARE @enumName NVARCHAR(100);
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	

	SELECT @enumName=[EnumName], @enumSchema=[Schema], @enumTable=[Table]
	FROM #Enum	
	WHERE [Id]=@enumId;

	IF @enumName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown enum';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumName', @enumName);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumSchema', QUOTENAME(@enumSchema));	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumTable', QUOTENAME(@enumTable));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'EnumAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Value', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_ENUM_START
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #EnumVal WHERE [EnumId]=@enumId);
	DECLARE @name NVARCHAR(100);
	DECLARE @value NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=[Name], @value=[Value] FROM #EnumVal WHERE [Id]=@id;
		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@value
		WHERE [Name]=N'Value';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_ENUM_ENTRY
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #EnumVal WHERE [EnumId]=@enumId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_ENUM_END
	ORDER BY c.[Id];

	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GenerateEndCode]...';


GO

CREATE PROCEDURE [Internal].[GenerateEndCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_START TINYINT = 1;
	DECLARE @TT_END TINYINT = 2;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);


	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_END
	ORDER BY c.[Id];

	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GetEnumValues]...';


GO

CREATE PROCEDURE [Internal].[GetEnumValues]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;
	

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	DECLARE @nameColumn NVARCHAR(128);
	DECLARE @valueColumn NVARCHAR(128);

	SELECT @enumSchema=[Schema], @enumTable=[Table], @nameColumn=[NameColumn], @valueColumn=[ValueColumn]
	FROM #Enum
	WHERE [Id]=@enumId;

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@enumId) + N' [EnumId], ' + QUOTENAME(@nameColumn) + N' [Name], ' + QUOTENAME(@valueColumn) + N' [Value] ' 
	SET @query += N'FROM ' + QUOTENAME(@enumSchema) + N'.' + QUOTENAME(@enumTable) + N' '
	SET @query += N'ORDER BY ' + QUOTENAME(@valueColumn)
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #EnumVal ([EnumId], [Name], [Value])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GetEnums]...';


GO
CREATE PROCEDURE [Internal].[GetEnums]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @generateAll BIT;

	SELECT @enumSchema = [EnumSchema], @generateAll=[GenerateAllEnumWrappers]
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @enumSchema IS NULL OR @generateAll<>1
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT SCHEMA_NAME(t.schema_id) [Schema], t.[name] [Table], nc.name [NameColumn], vc.name [ValueColumn], vct.[name] [ValueType] '
	SET @query += N'FROM sys.tables t '
	SET @query += N'JOIN sys.indexes pk ON pk.object_id=t.object_id AND pk.is_primary_key=1 '
	SET @query += N'JOIN sys.index_columns pkc ON pkc.object_id=pk.object_id AND pkc.index_id=pk.index_id AND pkc.index_column_id=1 AND pkc.is_included_column=0 '
	SET @query += N'JOIN sys.columns vc ON vc.object_id=pkc.object_id AND vc.column_id=pkc.column_id '
	SET @query += N'JOIN sys.types vct ON vct.system_type_id=vc.system_type_id AND vct.user_type_id=vc.user_type_id AND vct.name IN (''tinyint'', ''smallint'', ''int'', ''bigint'') '
	SET @query += N'JOIN sys.indexes ux ON ux.object_id=t.object_id AND ux.is_primary_key=0 AND ux.is_unique=1 '
	SET @query += N'JOIN sys.index_columns uxc ON uxc.object_id=ux.object_id AND uxc.index_id=ux.index_id AND uxc.index_column_id=1 AND uxc.is_included_column=0 '
	SET @query += N'JOIN sys.columns nc ON nc.object_id=uxc.object_id AND nc.column_id=uxc.column_id '
	SET @query += N'JOIN sys.types nct ON nct.system_type_id=nc.system_type_id AND nct.user_type_id=nc.user_type_id AND nct.name IN (''varchar'', ''nvarchar'') '
	SET @query += N'LEFT JOIN sys.index_columns pkc2 ON pkc2.object_id=pk.object_id AND pkc2.index_id=pk.index_id AND pkc2.index_column_id=2 '
	SET @query += N'LEFT JOIN sys.index_columns uxc2 ON uxc2.object_id=pk.object_id AND uxc2.index_id=ux.index_id AND uxc2.index_column_id=2 '
	SET @query += N'LEFT JOIN sys.columns idnc ON idnc.object_id=t.object_id AND idnc.is_identity=1 '
	SET @query += N'LEFT JOIN sys.indexes ux2 ON ux2.object_id=t.object_id AND ux2.is_primary_key=0 AND ux2.is_unique=1 AND ux2.index_id<>ux.index_id '
	SET @query += N'WHERE t.[Type]=''U'' AND idnc.column_id IS NULL AND pkc2.index_column_id IS NULL AND uxc2.index_column_id IS NULL AND ux2.index_id IS NULL '
	SET @query += N'AND SCHEMA_NAME(t.schema_id)=''' + @enumSchema + N''' '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #Enum ([Schema], [Table], [NameColumn], [ValueColumn], [ValueType])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[PrintError]...';


GO

CREATE PROCEDURE [Internal].[PrintError] 
AS
BEGIN
    SET NOCOUNT ON;
	-- source: AdventureWorks sample database
    -- Print error information. 
    PRINT 'Error ' + CONVERT(varchar(50), ERROR_NUMBER()) +
          ', Severity ' + CONVERT(varchar(5), ERROR_SEVERITY()) +
          ', State ' + CONVERT(varchar(5), ERROR_STATE()) + 
          ', Procedure ' + ISNULL(ERROR_PROCEDURE(), '-') + 
          ', Line ' + CONVERT(varchar(5), ERROR_LINE());
    PRINT ERROR_MESSAGE();
END;
GO
PRINT N'Creating Procedure [Internal].[GenerateResultTypeCode]...';


GO



CREATE PROCEDURE [Internal].[GenerateResultTypeCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@rtId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
	DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
	DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;

	DECLARE @spId INT;
	DECLARE @typeName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);

	DECLARE @className NVARCHAR(100);
	
	SELECT @className=p.[ClassName]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @spId=rt.[StoredProcId], @typeName=rt.[Name], @spSchema=sp.[Schema], @spName=sp.[Name]
	FROM #StoredProcResultType rt
	JOIN #StoredProc sp ON rt.[StoredProcId]=sp.[Id]
	WHERE rt.[Id]=@rtId;

	IF @typeName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown result type';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', QUOTENAME(@spSchema));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', QUOTENAME(@spName));
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_RESULT_TYPE_START
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId);
	DECLARE @name NVARCHAR(100);
	DECLARE @type NVARCHAR(100);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=rs.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END
		FROM #StoredProcResultSet rs 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=rs.[SqlType]
		LEFT JOIN #Enum e ON rs.[EnumId]=e.[Id]
		WHERE rs.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_RESULT_TYPE_PROPERTY
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcResultSet WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_RESULT_TYPE_END
	ORDER BY c.[Id];

	

END
GO
PRINT N'Creating Procedure [Internal].[GetStoredProcResultSet]...';


GO



CREATE PROCEDURE [Internal].[GetStoredProcResultSet]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	
	DECLARE @mapEnums TINYINT;

	SELECT @mapEnums=[MapResultSetEnums]
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @mapEnums IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @spSchema = [Schema], @spName=[Name]
	FROM #StoredProc
	WHERE [Id]=@spId;

	IF @spSchema IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @tsql NVARCHAR(4000);

	TRUNCATE TABLE #SingleStoredProcResultSet;
	

	SET @tsql = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @tsql += N'EXEC ' + QUOTENAME(@spSchema) + N'.' + QUOTENAME(@spName)
	
	--PRINT(@tsql);
	
	INSERT INTO #SingleStoredProcResultSet 	
	EXEC sys.sp_describe_first_result_set @tsql, NULL, 1;

	--SELECT * FROM  #SingleStoredProcResultSet;

	/*
	 * Join is with local sys.types view, so we can only use system types, not user defined types.	 
	 */
	
	INSERT INTO #StoredProcResultSet
	([StoredProcId], [ColumnOrdinal], [Name], [IsNullable], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale], [EnumId])
	SELECT @spId, rs.[column_ordinal], rs.[name], rs.[is_nullable], st.[name], SCHEMA_NAME(st.[schema_id]), rs.[max_length], rs.[precision], rs.[scale], e.[EnumId]
	FROM #SingleStoredProcResultSet rs
	JOIN sys.types st ON st.[system_type_id]=rs.[system_type_id] AND st.[user_type_id]=rs.[system_type_id]
	LEFT JOIN #EnumForeignKey e 
	ON @mapEnums=1 AND rs.[source_server] IS NULL AND rs.[source_database]=@dbName AND rs.[source_schema]=e.[ForeignSchema] AND rs.[source_table]=e.[ForeignTable] AND rs.[source_column]=e.[ForeignColumn]
	WHERE rs.[is_hidden]=0
	ORDER BY rs.[column_ordinal];
	
END
GO
PRINT N'Creating Procedure [Internal].[GetEnumForeignKeys]...';


GO


CREATE PROCEDURE [Internal].[GetEnumForeignKeys]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@enumId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;
	

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END
	
	DECLARE @enumSchema NVARCHAR(128);
	DECLARE @enumTable NVARCHAR(128);
	DECLARE @nameColumn NVARCHAR(128);
	DECLARE @valueColumn NVARCHAR(128);

	SELECT @enumSchema=[Schema], @enumTable=[Table], @nameColumn=[NameColumn], @valueColumn=[ValueColumn]
	FROM #Enum
	WHERE [Id]=@enumId;

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@enumId) + N' [EnumId], sch.name [ForeignSchema], tab1.name [ForeignTable], col1.name [ForeignColumn] ' 
	SET @query += N'FROM sys.foreign_key_columns fkc '
	SET @query += N'INNER JOIN sys.objects obj ON obj.object_id = fkc.constraint_object_id '
	SET @query += N'INNER JOIN sys.tables tab1 ON tab1.object_id = fkc.parent_object_id '
	SET @query += N'INNER JOIN sys.schemas sch ON tab1.schema_id = sch.schema_id '
	SET @query += N'INNER JOIN sys.columns col1 ON col1.column_id = parent_column_id AND col1.object_id = tab1.object_id '
	SET @query += N'INNER JOIN sys.tables tab2 ON tab2.object_id = fkc.referenced_object_id '
	SET @query += N'INNER JOIN sys.schemas sch2 ON tab2.schema_id = sch2.schema_id '
	SET @query += N'INNER JOIN sys.columns col2 ON col2.column_id = referenced_column_id AND col2.object_id = tab2.object_id '
	SET @query += N'WHERE sch2.name=' + QUOTENAME(@enumSchema, '''') + N' AND tab2.name=' + QUOTENAME(@enumTable, '''') + N' AND col2.name=' + QUOTENAME(@valueColumn, '''');
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #EnumForeignKey ([EnumId], [ForeignSchema], [ForeignTable], [ForeignColumn])
	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GenerateStoredProcWrapperCode]...';


GO




CREATE PROCEDURE [Internal].[GenerateStoredProcWrapperCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@spId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_WRAPPER_START TINYINT = 10;
	DECLARE @TT_WRAPPER_END TINYINT = 11;
	DECLARE @TT_WRAPPER_PREP TINYINT = 12;
	DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
	DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
	DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT_OUTPUT TINYINT = 18;
	DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
	DECLARE @TT_WRAPPER_START2 TINYINT = 20;
	DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
	DECLARE @TT_WRAPPER_END2 TINYINT = 22;
	DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
	DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;

	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;
	
	DECLARE @wrapperName NVARCHAR(200);
	DECLARE @spSchema NVARCHAR(128);
	DECLARE @spName NVARCHAR(128);
	DECLARE @hasResultSet BIT;
	DECLARE @resultType NVARCHAR(200);
	

	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);	
	DECLARE @genStaticClass BIT; 
	DECLARE @treatOutputParamAsInputOutput BIT;

	SELECT @className=p.[ClassName], @classAccess=ca.[Name], @genStaticClass=p.[GenerateStaticClass], @treatOutputParamAsInputOutput=p.[TreatOutputParamAsInputOutput]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @wrapperName=sp.[WrapperName], @spSchema=sp.[Schema], @spName=sp.[Name], @hasResultSet=sp.[HasResultSet], @resultType=[ResultType]
	FROM #StoredProc sp 
	WHERE sp.[Id]=@spId;

	IF @wrapperName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown stored procedure';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

	DECLARE @methodAccess NVARCHAR(200) = N'public';

	IF @genStaticClass=1
	BEGIN
		SET @methodAccess = @methodAccess + N' static';
	END

    -- DECLARE @query NVARCHAR(4000);

	DECLARE @resultTypeSingle NVARCHAR(200) = @resultType;

	IF @hasResultSet=1
	BEGIN
		SET @resultType = 'IList<' + @resultType + '>';
	END;

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'WrapperName', @wrapperName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpSchema', QUOTENAME(@spSchema));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'SpName', QUOTENAME(@spName));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultType', @resultType);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultTypeSingle', @resultTypeSingle);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarName', CASE WHEN @hasResultSet=1 THEN N'result' ELSE 'returnValue' END);
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'MethodAccess', @methodAccess);
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TypeCast', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ParamName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ParamOpt', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'DbType', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Size', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Precision', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Scale', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'OutVarDecl', CASE WHEN @treatOutputParamAsInputOutput=1 THEN N'' ELSE N'var ' END);

	INSERT INTO @vars ([Name], [Value]) VALUES (N'DtName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ReaderName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TvpName', NULL);	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TableType', NULL);	
	
	DECLARE @id INT = (SELECT MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL THEN N',' ELSE N'' END WHERE [Name]=N'Sep';
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleStart', CASE WHEN @id IS NOT NULL THEN N'(' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TupleEnd', CASE WHEN @id IS NOT NULL THEN N')' ELSE N'' END);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ResultVarNameTuple', CASE WHEN @id IS NOT NULL THEN CASE WHEN @hasResultSet=1 THEN N' Result' ELSE ' ReturnValue' END ELSE N'' END);

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_START
	ORDER BY c.[Id];

	
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1);
	DECLARE @name NVARCHAR(100);	
	DECLARE @type NVARCHAR(100);
	DECLARE @typeCast NVARCHAR(100);
	DECLARE @paramName NVARCHAR(100);
	DECLARE @paramOpt NVARCHAR(100);
	DECLARE @isOutput BIT;
	DECLARE @dbType NVARCHAR(100);
	DECLARE @size NVARCHAR(100);
	DECLARE @precision NVARCHAR(100);
	DECLARE @scale NVARCHAR(100);
	
	

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName= [Internal].[GetCaseName](@C_PASCAL_CASE, p.[ParamName], NULL), 
			@isOutput=p.[IsOutput],
			@paramOpt = CASE WHEN p.[IsOutput]=0 THEN N'' WHEN @treatOutputParamAsInputOutput=1 THEN N'ref ' ELSE N'out ' END
			--,[SizeNeeded]      ,[PrecisionNeeded]      ,[ScaleNeeded]
		FROM #StoredProcParam p 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
		UPDATE @vars
		SET [Value]=@paramOpt
		WHERE [Name]=N'ParamOpt';
		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_RETURN_PARAM_DEC
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_START2
	ORDER BY c.[Id];

	UPDATE @vars SET [Value]=',' WHERE [Name]=N'Sep';
	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0);
	DECLARE @isTableType BIT;
	
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(ISNULL(N'IEnumerable<' + @className + N'.' + tt.[Name] + N'>', @className + N'.' + e.[EnumName]), dtm.[NativeType]) + CASE WHEN tt.[Id] IS NULL AND dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, 
			@paramName=p.[ParamName], @isOutput=p.[IsOutput], @paramOpt = N'', @isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END
		FROM #StoredProcParam p 
		LEFT JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
		UPDATE @vars
		SET [Value]=@paramOpt
		WHERE [Name]=N'ParamOpt';
		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_PARAM
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND (@treatOutputParamAsInputOutput=1 OR [IsOutput]=0) AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_PREP
	ORDER BY c.[Id];

	DECLARE @dtName NVARCHAR(200);
	DECLARE @readerName NVARCHAR(200);
	DECLARE @tvpName NVARCHAR(300);
	DECLARE @tableType NVARCHAR(300);

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],
			@paramOpt = CASE WHEN p.[IsOutput]=0 THEN N'' WHEN @treatOutputParamAsInputOutput=1 THEN N'ref ' ELSE N'out ' END,
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' ELSE N'(' + dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END,
			@isTableType=CASE WHEN tt.[Id] IS NULL THEN 0 ELSE 1 END,
			@dtName=[Internal].[GetCaseName](@C_CAMEL_CASE, N'dt_' + @paramName, NULL),
			@readerName=[Internal].[GetCaseName](@C_CAMEL_CASE,@paramName + '_reader', NULL),
			@tvpName=QUOTENAME(tt.[SqlTypeSchema]) + N'.' + QUOTENAME(tt.[SqlType]),
			@tableType=@className + N'.' + tt.[Name]
		FROM #StoredProcParam p 
		LEFT JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #TableType tt ON p.[IsTableType]=1 AND p.[IsTypeUserDefined]=1 AND p.[SqlTypeSchema]=tt.[SqlTypeSchema] AND p.[SqlType]=tt.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
		UPDATE @vars
		SET [Value]=@paramOpt
		WHERE [Name]=N'ParamOpt';
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		UPDATE @vars
		SET [Value]=@tableType
		WHERE [Name]=N'TableType';
		


		UPDATE @vars
		SET [Value]=@dtName
		WHERE [Name]=N'DtName';
		UPDATE @vars
		SET [Value]=@readerName
		WHERE [Name]=N'ReaderName';
		UPDATE @vars
		SET [Value]=@tvpName
		WHERE [Name]=N'TvpName';
		
		
		
		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=
		CASE WHEN @isTableType=1 THEN @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE WHEN @isOutput=0 THEN @TT_WRAPPER_PARAM_PRE_EXEC_INPUT WHEN @treatOutputParamAsInputOutput=1 THEN @TT_WRAPPER_PARAM_PRE_EXEC_INPUT_OUTPUT ELSE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT END
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=CASE WHEN @hasResultSet=1 THEN @TT_WRAPPER_EXEC_RS ELSE @TT_WRAPPER_EXEC END
	ORDER BY c.[Id];

	
	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],
			@paramOpt = CASE WHEN p.[IsOutput]=0 THEN N'' WHEN @treatOutputParamAsInputOutput=1 THEN N'ref ' ELSE N'out ' END,
			@dbType=dtm.[DbType],
			@size=CASE WHEN dtm.[SizeNeeded]=1 THEN LOWER(p.[MaxLen]) ELSE 'null' END,
			@precision=CASE WHEN dtm.[PrecisionNeeded]=1 THEN LOWER(p.[Precision]) ELSE 'null' END,
			@scale=CASE WHEN dtm.[ScaleNeeded]=1 THEN LOWER(p.[Scale]) ELSE 'null' END,
			@typeCast=CASE WHEN e.[Id] IS NULL THEN N'' 
				ELSE N'(' + ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END + N') ' END
		FROM #StoredProcParam p 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
		UPDATE @vars
		SET [Value]=@paramOpt
		WHERE [Name]=N'ParamOpt';
		UPDATE @vars
		SET [Value]=@dbType
		WHERE [Name]=N'DbType';
		UPDATE @vars
		SET [Value]=@size
		WHERE [Name]=N'Size';
		UPDATE @vars
		SET [Value]=@precision
		WHERE [Name]=N'Precision';
		UPDATE @vars
		SET [Value]=@scale
		WHERE [Name]=N'Scale';
		UPDATE @vars
		SET [Value]=@typeCast
		WHERE [Name]=N'TypeCast';
		
		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_PARAM_POST_EXEC
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	SELECT @lastId=MAX([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1;
	
	UPDATE @vars SET [Value]=CASE WHEN @id IS NOT NULL THEN ',' ELSE '' END WHERE [Name]=N'Sep';
	
	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_END
	ORDER BY c.[Id];

	

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=p.[Name], @type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 THEN N'?' ELSE N'' END, @paramName=p.[ParamName], @isOutput=p.[IsOutput],
			@paramOpt = CASE WHEN p.[IsOutput]=0 THEN N'' WHEN @treatOutputParamAsInputOutput=1 THEN N'ref ' ELSE N'out ' END
			--,[SizeNeeded]      ,[PrecisionNeeded]      ,[ScaleNeeded]
		FROM #StoredProcParam p 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=p.[SqlType]
		LEFT JOIN #Enum e ON p.[EnumId]=e.[Id]
		WHERE p.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		UPDATE @vars
		SET [Value]=@paramName
		WHERE [Name]=N'ParamName';
		UPDATE @vars
		SET [Value]=@paramOpt
		WHERE [Name]=N'ParamOpt';
		
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_RETURN_PARAM
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #StoredProcParam WHERE [StoredProcId]=@spId AND [IsOutput]=1 AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_WRAPPER_END2
	ORDER BY c.[Id];
END
GO
PRINT N'Creating Procedure [Internal].[GenerateStartCode]...';


GO

CREATE PROCEDURE [Internal].[GenerateStartCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_START TINYINT = 1;
	DECLARE @TT_STATIC_START TINYINT = 9;

	DECLARE @namespaceName NVARCHAR(100);
	DECLARE @className NVARCHAR(100);
	DECLARE @classAccess NVARCHAR(100);
	DECLARE @projectName NVARCHAR(200);
	DECLARE @genStaticClass BIT; 
	

	SELECT @namespaceName = p.[NamespaceName], @className=p.[ClassName], @classAccess=ca.[Name], @projectName=p.[Name], @genStaticClass=p.[GenerateStaticClass]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	DECLARE @vars [Internal].[Variable];
	 
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ServerName', CAST(serverproperty('servername') AS NVARCHAR(500)));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'InstanceName', @@SERVICENAME);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Database', @dbName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ProjectName', @projectName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'NamespaceName', @namespaceName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @className);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', @classAccess);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Timestamp', CONVERT(NVARCHAR(50), CAST(SYSDATETIME() AS DATETIME2(0)), 120));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolName', N'MsSqlDbProjectHelper');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ToolUrl', N'https://github.com/rkozlowski/MsSqlDbProjectHelper');
	INSERT INTO @vars ([Name], [Value]) 
	SELECT TOP(1) N'ToolVersion', [Version]
	FROM [dbo].[Version]
	ORDER BY [Id] DESC;


	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=CASE WHEN @genStaticClass=1 THEN @TT_STATIC_START ELSE @TT_START END
	ORDER BY c.[Id];

	EXEC(@query);

END
GO
PRINT N'Creating Procedure [Internal].[GetTableTypeColumns]...';


GO



CREATE PROCEDURE [Internal].[GetTableTypeColumns]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@ttId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @PEM_EXPLICIT_ONLY TINYINT = 1;
	DECLARE @PEM_ENUM_NAME TINYINT = 2;
	DECLARE @PEM_ENUM_NAME_WITH_ID TINYINT = 3;
	DECLARE @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID TINYINT = 4;

	DECLARE @schema NVARCHAR(128);
	DECLARE @name NVARCHAR(128);

	DECLARE @pemId TINYINT;

	SELECT @pemId=[ParamEnumMappingId]      
	FROM [dbo].[Project]
	WHERE [Id]=@projectId;

	IF @pemId IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END
	

	SELECT @name=[SqlType], @schema=[SqlTypeSchema]
	FROM #TableType
	WHERE [Id]=@ttId;

	IF @name IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project or unsupported project options';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	

	SET @query = N'USE ' + QUOTENAME(@dbName) + N';
	';
	SET @query += N'SELECT ' + LOWER(@ttId) + N' [TableTypeId], c.[column_id] [ColumnId], c.[name] [Name], c.is_nullable [IsNullable], t.[name] [SqlType], SCHEMA_NAME(t.schema_id) [SqlTypeSchema], '
	SET @query += N'c.[max_length] [MaxLen], c.[precision] [Precision], c.[scale] [Scale] '
	SET @query += N'FROM sys.table_types tt '
	SET @query += N'JOIN sys.columns c on c.object_id = tt.type_table_object_id '
	SET @query += N'JOIN sys.types t ON c.system_type_id=t.system_type_id AND c.system_type_id = t.user_type_id '
	SET @query += N'WHERE SCHEMA_NAME(tt.schema_id)=' + QUOTENAME(@schema, N'''') + N' AND tt.[name]=' + QUOTENAME(@name, N'''') + N' '
	SET @query += N'ORDER BY c.[column_id] '
	SET @query += N';
	';
	--PRINT(@query);
	
	INSERT INTO #TableTypeColumn
	([TableTypeId], [ColumnId], [Name], [IsNullable], [SqlType], [SqlTypeSchema], [MaxLen], [Precision], [Scale])
	EXEC(@query);

	IF (@pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID))
	BEGIN
		UPDATE ttc
		SET ttc.[EnumId]=e.[Id]
		FROM #TableTypeColumn ttc
		JOIN #Enum e ON ttc.[SqlType]=e.[ValueType] 
		AND ((e.[EnumName]=[Internal].[RemoveFromStart](ttc.[Name], N'@') AND @pemId IN (@PEM_ENUM_NAME, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)) 
		OR (ttc.[Name] LIKE N'%Id' AND e.[EnumName]=[Internal].[RemoveFromEnd]([Internal].[RemoveFromStart](ttc.[Name], N'@'), N'Id') AND @pemId IN (@PEM_ENUM_NAME_WITH_ID, @PEM_ENUM_NAME_WITH_OR_WITHOUT_ID)))
	END
	SET @rc=@RC_OK;
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Internal].[GenerateTableTypeCode]...';


GO




CREATE PROCEDURE [Internal].[GenerateTableTypeCode]
	@projectId SMALLINT,
	@dbId SMALLINT,
	@langId TINYINT,
	@ttId INT,
	@errorMessage NVARCHAR(2000) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @rc INT;

	DECLARE @RC_OK INT = 1;
	DECLARE @RC_ERR_PROJECT INT = 21;
	DECLARE @RC_ERR_DB INT = 22;
	DECLARE @RC_ERR_LANG INT = 23;

	DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
	DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
	DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
	DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
	DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
	DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
	DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
	DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
	DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
	DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
	DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
	DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;

	DECLARE @typeName NVARCHAR(200);
	DECLARE @ttSchema NVARCHAR(128);
	DECLARE @ttName NVARCHAR(128);

	DECLARE @className NVARCHAR(100);
	
	SELECT @className=p.[ClassName]
	FROM [dbo].[Project] p
	JOIN [Enum].[ClassAccess] ca ON p.[ClassAccessId]=ca.[Id]
	WHERE p.[Id]=@projectId;

	IF @className IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown project';
		RETURN @rc;
	END

	SELECT @typeName=tt.[Name], @ttSchema=tt.[SqlTypeSchema], @ttName=tt.[SqlType]
	FROM #TableType tt	
	WHERE tt.[Id]=@ttId;

	IF @typeName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_PROJECT, @errorMessage=N'Unknown table type';
		RETURN @rc;
	END

	DECLARE @dbName NVARCHAR(128) = DB_NAME(@dbId);

	IF @dbName IS NULL
	BEGIN
		SELECT @rc = @RC_ERR_DB, @errorMessage=N'Database not found';
		RETURN @rc;
	END

    DECLARE @query NVARCHAR(4000);

	DECLARE @vars [Internal].[Variable];
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassName', @typeName);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TtSchema', QUOTENAME(@ttSchema));
	INSERT INTO @vars ([Name], [Value]) VALUES (N'TtName', QUOTENAME(@ttName));
	
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ClassAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'PropertyAccess', N'public');
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Type', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Name', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'BaseType', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'ColumnName', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'AllowNull', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'MaxLength', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Cast', NULL);
	INSERT INTO @vars ([Name], [Value]) VALUES (N'Sep', N',');
	


	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_START
	ORDER BY c.[Id];

	DECLARE @id INT = (SELECT MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId);
	DECLARE @lastId INT = (SELECT MAX([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId);
	DECLARE @name NVARCHAR(128);
	DECLARE @columnName NVARCHAR(128);
	DECLARE @type NVARCHAR(128);
	DECLARE @baseType NVARCHAR(128);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=ttc.[PropertyName], @columnName=ttc.[Name], @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
		@type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END
		FROM #TableTypeColumn ttc 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
		LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
		WHERE ttc.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_PROPERTY
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_START
	ORDER BY c.[Id];

	SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId;
	DECLARE @allowNull BIT
	DECLARE @maxLength INT;

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=ttc.[PropertyName], @columnName=ttc.[Name], @baseType=dtm.[NativeType], -- + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
		@type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
		@allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END
		FROM #TableTypeColumn ttc 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
		LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
		WHERE ttc.[Id]=@id;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';

		UPDATE @vars
		SET [Value]=@columnName
		WHERE [Name]=N'ColumnName';
		UPDATE @vars
		SET [Value]=@baseType
		WHERE [Name]=N'BaseType';

		UPDATE @vars
		SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
		WHERE [Name]=N'AllowNull';
		UPDATE @vars
		SET [Value]=@maxLength
		WHERE [Name]=N'MaxLength';

		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_COLUMN
		ORDER BY c.[Id];

		IF @maxLength IS NOT NULL
		BEGIN

			INSERT INTO #Output ([Text])
			SELECT c.[Text]
			FROM [dbo].[Template] t
			CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
			WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_COLUMN_MAX_LEN
			ORDER BY c.[Id];

		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_COLUMN_ADD
		ORDER BY c.[Id];

		SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_ROWS_START
	ORDER BY c.[Id];

	SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId;
	DECLARE @cast NVARCHAR(200);

	WHILE @id IS NOT NULL
	BEGIN		
		SELECT @name=ttc.[PropertyName], @columnName=ttc.[Name], @baseType=dtm.[NativeType] + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,
		@type=ISNULL(@className + N'.' + e.[EnumName], dtm.[NativeType]) + CASE WHEN dtm.[IsNullable]=0 AND ttc.[IsNullable]=1 THEN N'?' ELSE N'' END,		
		@allowNull=ttc.[IsNullable], @maxLength=CASE WHEN dtm.[SizeNeeded]=1 THEN ttc.[MaxLen] ELSE NULL END
		FROM #TableTypeColumn ttc 
		JOIN [dbo].[DataTypeMap] dtm ON dtm.[SqlType]=ttc.[SqlType]
		LEFT JOIN #Enum e ON ttc.[EnumId]=e.[Id]
		WHERE ttc.[Id]=@id;

		SET @cast = CASE WHEN @baseType = @type THEN N'' ELSE N'(' + @baseType + N') ' END;

		UPDATE @vars
		SET [Value]=@name
		WHERE [Name]=N'Name';
		UPDATE @vars
		SET [Value]=@type
		WHERE [Name]=N'Type';

		UPDATE @vars
		SET [Value]=@columnName
		WHERE [Name]=N'ColumnName';
		UPDATE @vars
		SET [Value]=@baseType
		WHERE [Name]=N'BaseType';		

		UPDATE @vars
		SET [Value]=CASE WHEN @allowNull=1 THEN N'true' ELSE N'false' END
		WHERE [Name]=N'AllowNull';
		UPDATE @vars
		SET [Value]=@maxLength
		WHERE [Name]=N'MaxLength';

		UPDATE @vars
		SET [Value]=@cast
		WHERE [Name]=N'Cast';
		
		IF @id=@lastId
		BEGIN
			UPDATE @vars
			SET [Value]=''
			WHERE [Name]=N'Sep';
		END

		INSERT INTO #Output ([Text])
		SELECT c.[Text]
		FROM [dbo].[Template] t
		CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
		WHERE t.[LanguageId]=@langId AND t.[TypeId]=CASE WHEN @allowNull=1 THEN @TT_TABLE_TYPE_DT_ROW_NULL ELSE @TT_TABLE_TYPE_DT_ROW END
		ORDER BY c.[Id];		

		SELECT @id=MIN([Id]) FROM #TableTypeColumn WHERE [TableTypeId]=@ttId AND [Id]>@id;
	END

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_ROWS_END
	ORDER BY c.[Id];

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_DT_END
	ORDER BY c.[Id];

	INSERT INTO #Output ([Text])
	SELECT c.[Text]
	FROM [dbo].[Template] t
	CROSS APPLY [Internal].[ProcessTemplate](t.[Template], @vars) c
	WHERE t.[LanguageId]=@langId AND t.[TypeId]=@TT_TABLE_TYPE_END
	ORDER BY c.[Id];

	

END
GO
PRINT N'Creating Procedure [Project].[GenerateCode]...';


GO
CREATE PROCEDURE [Project].[GenerateCode]
	@projectName NVARCHAR(200),
	@errorMessage NVARCHAR(2000) OUTPUT,
	@databaseName NVARCHAR(128) = NULL,	
	@options INT = NULL
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE  @rc INT;

	DECLARE @RC_OK INT = 0;
	DECLARE @RC_ERR_UNKNOWN_PROJECT INT = 1;
	DECLARE @RC_ERR_UNKNOWN_DB INT = 2;

	SELECT @rc = @RC_OK, @errorMessage = NULL;

	DROP TABLE IF EXISTS #Output;

	DECLARE @OPT_GEN_ENUMS INT = 1;
	DECLARE @OPT_GEN_RESULT_TYPES INT = 2;
	DECLARE @OPT_GEN_TVP_TYPES INT = 4;
	DECLARE @OPT_GEN_SP_WRAPPERS INT = 8;

	DECLARE @OPT_GEN_ALL INT = (@OPT_GEN_ENUMS | @OPT_GEN_RESULT_TYPES | @OPT_GEN_TVP_TYPES | @OPT_GEN_SP_WRAPPERS);


	DECLARE @C_PASCAL_CASE TINYINT = 1;
	DECLARE @C_CAMEL_CASE TINYINT = 2;
	DECLARE @C_SNAKE_CASE TINYINT = 3;
	DECLARE @C_UNDERSCORE_CAMEL_CASE TINYINT = 4;
	DECLARE @C_UPPER_SNAKE_CASE TINYINT = 5;

	IF ISNULL(@options, 0)=0 
	BEGIN
		SET @options = @OPT_GEN_ALL;
	END

	DECLARE @projectId SMALLINT;
	DECLARE @langId TINYINT;
	

	SELECT @projectId=[Id], @langId=[LanguageId], @databaseName=ISNULL(@databaseName, [DefaultDatabase]) FROM [dbo].[Project] WHERE [Name]=@projectName;

	IF @projectId IS NULL 
	BEGIN
		SELECT @rc = @RC_ERR_UNKNOWN_PROJECT, @errorMessage = 'Unknown project: ' + ISNULL(@projectName, '<NULL>');
		RETURN @rc;
	END;

	DECLARE @dbId SMALLINT = DB_ID(@databaseName);

	IF @dbId IS NULL 
	BEGIN
		SELECT @rc = @RC_ERR_UNKNOWN_DB, @errorMessage = 'Unknown database: ' + ISNULL(@databaseName, '<NULL>')
		RETURN @rc;
	END;

	DROP TABLE IF EXISTS #Enum;
	CREATE TABLE #Enum
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,		
		[Schema] NVARCHAR(128) NOT NULL,
		[Table] NVARCHAR(128) NOT NULL,		
		[NameColumn] NVARCHAR(128) NOT NULL,
		[ValueColumn] NVARCHAR(128) NOT NULL,
		[EnumName] NVARCHAR(200) NULL,
		[ValueType] NVARCHAR(128) NOT NULL,
		UNIQUE ([Schema], [Table])
	);

	DROP TABLE IF EXISTS #EnumVal;
	CREATE TABLE #EnumVal
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,		
		[EnumId] INT NOT NULL,		
		[Name] VARCHAR(200) NOT NULL,
		[Value] BIGINT NOT NULL,		
		UNIQUE ([EnumId], [Name]),
		UNIQUE ([EnumId], [Value])
	);

	DROP TABLE IF EXISTS #EnumForeignKey;
	CREATE TABLE #EnumForeignKey
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,		
		[EnumId] INT NOT NULL,
		[ForeignSchema] NVARCHAR(128) NOT NULL,
		[ForeignTable] NVARCHAR(128) NOT NULL,
		[ForeignColumn] NVARCHAR(128) NOT NULL,		
		UNIQUE ([EnumId], [ForeignSchema], [ForeignTable], [ForeignColumn]),
		UNIQUE ([ForeignSchema], [ForeignTable], [ForeignColumn])		
	);

	DROP TABLE IF EXISTS #StoredProc;
	CREATE TABLE #StoredProc 
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[Schema] NVARCHAR(128) NOT NULL, 
		[Name] NVARCHAR(128) NOT NULL,
		[WrapperName] NVARCHAR(200) NULL,
		[HasResultSet] BIT NOT NULL DEFAULT (0),
		[ResultType] NVARCHAR(200) NOT NULL DEFAULT(N'int'),
		UNIQUE ([Schema], [Name])
	);

	DROP TABLE IF EXISTS #StoredProcParam;
	CREATE TABLE #StoredProcParam
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[StoredProcId] INT NOT NULL,
		[ParamId] INT NOT NULL, 
		[Name] NVARCHAR(128) NOT NULL, 
		[SqlType] NVARCHAR(128) NOT NULL, 
		[SqlTypeSchema] NVARCHAR(128) NOT NULL, 
		[MaxLen] SMALLINT NOT NULL, 
		[Precision] TINYINT NOT NULL, 
		[Scale] TINYINT NOT NULL, 
		[IsOutput] BIT NOT NULL, 
		[IsReadOnly] BIT NOT NULL, 
		[IsTypeUserDefined] BIT NOT NULL, 
		[IsTableType] BIT NOT NULL,
		[EnumId] INT NULL,
		[ParamName]  NVARCHAR(200) NULL,
		UNIQUE ([StoredProcId], [ParamId]),
		UNIQUE ([StoredProcId], [Name])
	);

	DROP TABLE IF EXISTS #SingleStoredProcResultSet;
	CREATE TABLE #SingleStoredProcResultSet (
		[is_hidden] BIT NOT NULL,
		[column_ordinal] INT NOT NULL,
		[name] SYSNAME NULL,
		[is_nullable] BIT NOT NULL,
		[system_type_id] INT NOT NULL,
		[system_type_name] NVARCHAR(256) NULL,
		[max_length] SMALLINT NOT NULL,
		[precision] TINYINT NOT NULL,
		[scale] TINYINT NOT NULL,
		[collation_name] SYSNAME NULL,
		[user_type_id] INT NULL,
		[user_type_database] SYSNAME NULL,
		[user_type_schema] SYSNAME NULL,
		[user_type_name] SYSNAME NULL,
		[assembly_qualified_type_name] NVARCHAR(4000),
		[xml_collection_id] INT NULL,
		[xml_collection_database] SYSNAME NULL,
		[xml_collection_schema] SYSNAME NULL,
		[xml_collection_name] SYSNAME NULL,
		[is_xml_document] BIT NOT NULL,
		[is_case_sensitive] BIT NOT NULL,
		[is_fixed_length_clr_type] BIT NOT NULL,
		[source_server] SYSNAME NULL,
		[source_database] SYSNAME NULL,
		[source_schema] SYSNAME NULL,
		[source_table] SYSNAME NULL,
		[source_column] SYSNAME NULL,
		[is_identity_column] BIT NULL,
		[is_part_of_unique_key] BIT NULL,
		[is_updateable] BIT NULL,
		[is_computed_column] BIT NULL,
		[is_sparse_column_set] BIT NULL,
		[ordinal_in_order_by_list] SMALLINT NULL,
		[order_by_list_length] SMALLINT NULL,
		[order_by_is_descending] SMALLINT NULL,
		[tds_type_id] INT NOT NULL,
		[tds_length] INT NOT NULL,
		[tds_collation_id] INT NULL,
		[tds_collation_sort_id] TINYINT NULL
	);

	DROP TABLE IF EXISTS #StoredProcResultSet;
	CREATE TABLE #StoredProcResultSet (
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[StoredProcId] INT NOT NULL,
		[ColumnOrdinal] INT NOT NULL,
		[Name] SYSNAME NULL,
		[IsNullable] BIT NOT NULL,
		[SqlType] NVARCHAR(128) NOT NULL, 
		[SqlTypeSchema] NVARCHAR(128) NOT NULL, 
		[MaxLen] SMALLINT NOT NULL, 
		[Precision] TINYINT NOT NULL, 
		[Scale] TINYINT NOT NULL,
		[EnumId] INT NULL,
		UNIQUE ([StoredProcId], [ColumnOrdinal])
	);

	DROP TABLE IF EXISTS #StoredProcResultType;
	CREATE TABLE #StoredProcResultType
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[StoredProcId] INT NOT NULL UNIQUE,
		[Name] NVARCHAR(200) NOT NULL UNIQUE
	);

	DROP TABLE IF EXISTS #TableType;
	CREATE TABLE #TableType
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[SqlType] NVARCHAR(128) NOT NULL, 
		[SqlTypeSchema] NVARCHAR(128) NOT NULL,
		[Name] NVARCHAR(200) NOT NULL UNIQUE,
		UNIQUE ([SqlType], [SqlTypeSchema])
	);

	DROP TABLE IF EXISTS #TableTypeColumn;
	CREATE TABLE #TableTypeColumn
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[TableTypeId] INT NOT NULL,
		[ColumnId] INT NOT NULL,
		[Name] SYSNAME NULL,
		[IsNullable] BIT NOT NULL,
		[SqlType] NVARCHAR(128) NOT NULL, 
		[SqlTypeSchema] NVARCHAR(128) NOT NULL, 
		[MaxLen] SMALLINT NOT NULL, 
		[Precision] TINYINT NOT NULL, 
		[Scale] TINYINT NOT NULL,
		[EnumId] INT NULL,
		[PropertyName] NVARCHAR(200) NULL,
	);

	DECLARE	@retVal int;
	
	
    EXEC @retVal = [Internal].[GetEnums] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
	IF @retVal<>0
	BEGIN
		SELECT @rc = @retVal;
		RETURN @rc;
	END

	UPDATE #Enum SET [EnumName]=[Internal].[GetName](@langId, [Table], [Schema]);

	DECLARE @id INT = (SELECT MIN([Id]) FROM #Enum);
	
	WHILE @id IS NOT NULL
	BEGIN
		EXEC @retVal = [Internal].[GetEnumValues] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END

		EXEC @retVal = [Internal].[GetEnumForeignKeys] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		

		SELECT @id = MIN([Id]) FROM #Enum WHERE [Id]>@id;
	END

	UPDATE #EnumVal SET [Name]=[Internal].[GetName](@langId, [Name], NULL);

	/*
	SELECT e.[Schema], e.[Table], e.[EnumName], fk.*
	FROM #Enum e
	JOIN #EnumForeignKey fk ON fk.[EnumId]=e.[Id]
	ORDER BY e.[Id], fk.[Id];
	*/

	EXEC @retVal = [Internal].[GetStoredProcedures] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
	IF @retVal<>0
	BEGIN
		SELECT @rc = @retVal;
		RETURN @rc;
	END

	SELECT @id=MIN([Id]) FROM #StoredProc;
	
	WHILE @id IS NOT NULL
	BEGIN
		EXEC @retVal = [Internal].[GetStoredProcParams] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		
		EXEC @retVal = [Internal].[GetStoredProcResultSet] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END

		SELECT @id = MIN([Id]) FROM #StoredProc WHERE [Id]>@id;
	END

	UPDATE #StoredProc SET [WrapperName]=[Internal].[GetName](@langId, [Name], [Schema]);

	UPDATE sp
	SET sp.[HasResultSet]=1, sp.[ResultType]=sp.[WrapperName] + N'Result'
	FROM #StoredProc sp
	WHERE EXISTS (SELECT 1 FROM #StoredProcResultSet rs WHERE rs.[StoredProcId]=sp.[Id]);
	
	INSERT INTO #StoredProcResultType ([StoredProcId], [Name])
	SELECT [Id], [ResultType]
	FROM #StoredProc
	WHERE [HasResultSet]=1;

	UPDATE #StoredProcParam SET [ParamName]=[Internal].[GetName](@langId, [Name], NULL);

	INSERT INTO #TableType ([SqlType], [SqlTypeSchema], [Name])
	SELECT DISTINCT spp.[SqlType], spp.[SqlTypeSchema], [Internal].[GetName](@langId, spp.[SqlType], spp.[SqlTypeSchema])
	FROM #StoredProcParam spp
	WHERE spp.[IsTypeUserDefined]=1 AND spp.IsTableType=1;

	SELECT @id=MIN([Id]) FROM #TableType;
	
	WHILE @id IS NOT NULL
	BEGIN
		EXEC @retVal = [Internal].[GetTableTypeColumns] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
		IF @retVal<>0
		BEGIN
			SELECT @rc = @retVal;
			RETURN @rc;
		END
		
		SELECT @id = MIN([Id]) FROM #TableType WHERE [Id]>@id;
	END

	UPDATE #TableTypeColumn
	SET [PropertyName]=[Internal].[GetCaseName](@C_PASCAL_CASE, [Name], NULL);

	--SELECT * FROM #Enum ORDER BY [Id];
	--SELECT * FROM #EnumVal ORDER BY [Id];
	--SELECT * FROM #StoredProc ORDER BY [Id];
	--SELECT * FROM #StoredProcParam ORDER BY [Id];
	--SELECT * FROM #StoredProcResultSet ORDER BY [Id];
	--SELECT * FROM #TableType;
	--SELECT * FROM #TableTypeColumn ORDER BY [Id];

	CREATE TABLE #Output
	(
		[Id] INT NOT NULL IDENTITY (1, 1) PRIMARY KEY,
		[Text] NVARCHAR(MAX) NOT NULL
	);

	
	EXECUTE @retVal = [Internal].[GenerateStartCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
	IF @retVal<>0
	BEGIN
		SELECT @rc = @retVal;
		RETURN @rc;
	END

	IF (@options & @OPT_GEN_ENUMS) = @OPT_GEN_ENUMS
	BEGIN
		 SELECT @id=MIN([Id]) FROM #Enum;
		 WHILE @id IS NOT NULL
		 BEGIN
			EXEC @retVal = [Internal].[GenerateEnumCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @enumId = @id, @errorMessage = @errorMessage OUTPUT;
			IF @retVal<>0
			BEGIN
				SELECT @rc = @retVal;
				RETURN @rc;
			END
			SELECT @id=MIN([Id]) FROM #Enum WHERE [Id] > @id;
		 END
	END

	IF (@options & @OPT_GEN_RESULT_TYPES) = @OPT_GEN_RESULT_TYPES
	BEGIN
		 SELECT @id=MIN([Id]) FROM #StoredProcResultType;
		 WHILE @id IS NOT NULL
		 BEGIN
			EXEC @retVal = [Internal].[GenerateResultTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @rtId = @id, @errorMessage = @errorMessage OUTPUT;
			IF @retVal<>0
			BEGIN
				SELECT @rc = @retVal;
				RETURN @rc;
			END
			SELECT @id=MIN([Id]) FROM #StoredProcResultType WHERE [Id] > @id;
		 END
	END

	IF (@options & @OPT_GEN_TVP_TYPES) = @OPT_GEN_TVP_TYPES
	BEGIN
		 SELECT @id=MIN([Id]) FROM #TableType;
		 WHILE @id IS NOT NULL
		 BEGIN
			EXEC @retVal = [Internal].[GenerateTableTypeCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @ttId = @id, @errorMessage = @errorMessage OUTPUT;
			IF @retVal<>0
			BEGIN
				SELECT @rc = @retVal;
				RETURN @rc;
			END
			SELECT @id=MIN([Id]) FROM #TableType WHERE [Id] > @id;
		 END
	END

	
	
	IF (@options & @OPT_GEN_SP_WRAPPERS) = @OPT_GEN_SP_WRAPPERS
	BEGIN
		 SELECT @id=MIN([Id]) FROM #StoredProc;
		 WHILE @id IS NOT NULL
		 BEGIN
			EXEC @retVal = [Internal].[GenerateStoredProcWrapperCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @spId = @id, @errorMessage = @errorMessage OUTPUT;
			IF @retVal<>0
			BEGIN
				SELECT @rc = @retVal;
				RETURN @rc;
			END
			SELECT @id=MIN([Id]) FROM #StoredProc WHERE [Id] > @id;
		 END
	END

	EXECUTE @retVal = [Internal].[GenerateEndCode] @projectId = @projectId, @dbId = @dbId, @langId = @langId, @errorMessage = @errorMessage OUTPUT;
	IF @retVal<>0
	BEGIN
		SELECT @rc = @retVal;
		RETURN @rc;
	END
	
	SELECT [Text]
	FROM #Output
	ORDER BY [Id];
	
	DROP TABLE IF EXISTS #Output;
	DROP TABLE IF EXISTS #Enum;
	DROP TABLE IF EXISTS #EnumVal;
	DROP TABLE IF EXISTS #StoredProc;
	DROP TABLE IF EXISTS #StoredProcParam;
	DROP TABLE IF EXISTS #SingleStoredProcResultSet;
	DROP TABLE IF EXISTS #EnumForeignKey;
	DROP TABLE IF EXISTS #StoredProcResultType;
	DROP TABLE IF EXISTS #TableType;
	DROP TABLE IF EXISTS #TableTypeColumn;

	SET @rc = @RC_OK;
	RETURN @rc;
END
GO
PRINT N'Creating Procedure [Internal].[LogError]...';


GO



CREATE PROCEDURE [Internal].[LogError] 
    @errorLogId [int] = 0 OUTPUT -- contains the ID of the row inserted
AS                               -- by [Internal].[LogError] Stored Procedure in the ErrorLog table
BEGIN
    SET NOCOUNT ON;

	-- source: AdventureWorks sample database

    -- Output parameter value of 0 indicates that error 
    -- information was not logged
    SET @errorLogId = 0;

    BEGIN TRY
        -- Return if there is no error information to log
        IF ERROR_NUMBER() IS NULL
            RETURN;

        -- Return if inside an uncommittable transaction.
        -- Data insertion/modification is not allowed when 
        -- a transaction is in an uncommittable state.
        IF XACT_STATE() = -1
        BEGIN
            PRINT 'Cannot log error since the current transaction is in an uncommittable state. ' 
                + 'Rollback the transaction before executing uspLogError in order to successfully log error information.';
            RETURN;
        END

        INSERT [dbo].[ErrorLog] 
            (
            [UserName], 
            [ErrorNumber], 
            [ErrorSeverity], 
            [ErrorState], 
            [ErrorProcedure], 
            [ErrorLine], 
            [ErrorMessage]
            ) 
        VALUES 
            (
            CONVERT(sysname, CURRENT_USER), 
            ERROR_NUMBER(),
            ERROR_SEVERITY(),
            ERROR_STATE(),
            ERROR_PROCEDURE(),
            ERROR_LINE(),
            ERROR_MESSAGE()
            );

        -- Pass back the ErrorLogID of the row inserted
        SET @errorLogId = @@IDENTITY;
    END TRY
    BEGIN CATCH
        PRINT 'An error occurred in stored procedure uspLogError: ';
        EXECUTE [Internal].[PrintError];
        RETURN -1;
    END CATCH
END;
GO
PRINT N'Creating Procedure [Project].[CreateProject]...';


GO
CREATE PROCEDURE [Project].[CreateProject]
	@name NVARCHAR(200),
	@namespaceName VARCHAR(100),
	@className VARCHAR(100),
	@errorMessage NVARCHAR(2000) OUTPUT,
	@defaultDatabase NVARCHAR(128) = NULL,
	@enumSchema NVARCHAR(128) = NULL,
	@storedProcSchema NVARCHAR(128) = NULL,
	@classAccess VARCHAR(200) = 'public',	
	@generateAllStoredProcWrappers BIT = 1,
	@generateAllEnumWrappers BIT = 1,
	@language VARCHAR(200) = 'c#',
	@paramEnumMappingId TINYINT = 1, 
	@mapResultSetEnums BIT = 0, 
	@generateStaticClass BIT = 0, 
	@treatOutputParamAsInputOutput BIT = 0
AS
BEGIN
	SET NOCOUNT ON;
	SET XACT_ABORT ON;

    SET LOCK_TIMEOUT 1000; -- wait for up to 1 seconds for a lock to be released.
	SET DEADLOCK_PRIORITY NORMAL;

	DECLARE @RC_OK INT = 0;	
	DECLARE @RC_UNKNOWN_CLASS_ACCESS INT = 1;
	DECLARE @RC_UNKNOWN_LANG INT = 2;
	DECLARE @RC_DB_ERROR INT = 51;
	DECLARE @RC_UNKNOWN_ERROR INT = 99;

	DECLARE @rc INT = @RC_UNKNOWN_ERROR;
	
	DECLARE @tranCount INT = @@TRANCOUNT;

	DECLARE @classAccessId TINYINT = (SELECT [Id] FROM [Enum].[ClassAccess] WHERE [Name]=@classAccess);
	IF @classAccessId IS NULL
	BEGIN
		SELECT @rc=@RC_UNKNOWN_CLASS_ACCESS, @errorMessage='Unknown class access: ' + ISNULL(@classAccess, '<NULL>');
		RETURN @rc;
	END

	DECLARE @languageId TINYINT = (SELECT [Id] FROM [Enum].[Language] WHERE [Name]=@language);
	IF @languageId IS NULL
	BEGIN
		SELECT @rc=@RC_UNKNOWN_LANG, @errorMessage='Unknown language: ' + ISNULL(@language, '<NULL>');
		RETURN @rc;
	END


	BEGIN TRY
		IF @tranCount = 0
			BEGIN TRANSACTION
		ELSE
			SAVE TRANSACTION TrnSp; 

		INSERT INTO [dbo].[Project] 
		([Name], [NamespaceName], [ClassName], [ClassAccessId], [EnumSchema], [StoredProcSchema], [GenerateAllStoredProcWrappers], [GenerateAllEnumWrappers], [LanguageId],
		[ParamEnumMappingId], [MapResultSetEnums], [GenerateStaticClass], [TreatOutputParamAsInputOutput], [DefaultDatabase])
		VALUES
        (@name, @namespaceName, @className, @classAccessId, @enumSchema, @storedProcSchema, @generateAllStoredProcWrappers, @generateAllEnumWrappers, @languageId,
		@paramEnumMappingId, @mapResultSetEnums, @generateStaticClass, @treatOutputParamAsInputOutput, @defaultDatabase);


		IF @tranCount = 0    
			COMMIT TRANSACTION

		SET @rc = @RC_OK;
	END TRY
	BEGIN CATCH
		SET @rc = @RC_DB_ERROR;
        

		SET @errorMessage = ERROR_MESSAGE();

		DECLARE @xstate INT;
		SELECT @xstate = XACT_STATE();
			
		IF @xstate = -1
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount = 0
			ROLLBACK TRANSACTION;
		IF @xstate = 1 and @tranCount > 0
			ROLLBACK TRANSACTION TrnSp;
		
		EXEC [Internal].[LogError];
	END CATCH

	
	RETURN @rc;
END
GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

--table [Enum].[Language]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Language] WHERE [Id]=1) 
INSERT INTO [Enum].[Language] ([Id], [Name]) 
VALUES (1, N'c#');


--table [Enum].[ClassAccess]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=1) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (1, N'public');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=2) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (2, N'protected');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=3) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (3, N'private');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=4) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (4, N'internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=5) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (5, N'protected internal');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ClassAccess] WHERE [Id]=6) 
INSERT INTO [Enum].[ClassAccess] ([Id], [Name]) 
VALUES (6, N'private protected');


--table [Enum].[Casing]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=1) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (1, N'PascalCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=2) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (2, N'CamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=3) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (3, N'SnakeCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=4) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (4, N'UnderscoreCamelCase');

IF NOT EXISTS (SELECT 1 FROM [Enum].[Casing] WHERE [Id]=5) 
INSERT INTO [Enum].[Casing] ([Id], [Name]) 
VALUES (5, N'UpperSnakeCase');


--table [Enum].[ParamEnumMapping]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=1) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (1, N'ExplicitOnly');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=2) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (2, N'EnumName');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=3) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (3, N'EnumNameWithId');

IF NOT EXISTS (SELECT 1 FROM [Enum].[ParamEnumMapping] WHERE [Id]=4) 
INSERT INTO [Enum].[ParamEnumMapping] ([Id], [Name]) 
VALUES (4, N'EnumNameWithOrWithoutId');


--table [Enum].[TemplateType]
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=1) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (1, N'Start');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=2) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (2, N'End');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=3) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (3, N'EnumStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=4) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (4, N'EnumEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=5) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (5, N'EnumEntry');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=6) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (6, N'ResultTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=7) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (7, N'ResultTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=8) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (8, N'ResultTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=9) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (9, N'StaticStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=10) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (10, N'WrapperStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=11) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (11, N'WrapperEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=12) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (12, N'WrapperPrep');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=13) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (13, N'WrapperExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=14) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (14, N'WrapperParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=15) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (15, N'WrapperParamPreExecInput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=16) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (16, N'WrapperParamPreExecOutput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=17) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (17, N'WrapperExecRS');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=18) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (18, N'WrapperParamPreExecInputOutput');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=19) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (19, N'WrapperParamPostExec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=20) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (20, N'WrapperStart2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=21) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (21, N'WrapperReturnParam');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=22) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (22, N'WrapperEnd2');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=23) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (23, N'WrapperReturnParamDec');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=24) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (24, N'TableTypeStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=25) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (25, N'TableTypeEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=26) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (26, N'TableTypeProperty');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=27) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (27, N'WrapperParamPreExecTableType');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=28) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (28, N'TableTypeDtStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=29) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (29, N'TableTypeDtEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=30) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (30, N'TableTypeDtColumn');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=31) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (31, N'TableTypeDtRowsStart');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=32) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (32, N'TableTypeDtRowsEnd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=33) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (33, N'TableTypeDtRow');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=34) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (34, N'TableTypeDtColumnAdd');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=35) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (35, N'TableTypeDtColumnMaxLen');

IF NOT EXISTS (SELECT 1 FROM [Enum].[TemplateType] WHERE [Id]=36) 
INSERT INTO [Enum].[TemplateType] ([Id], [Name]) 
VALUES (36, N'TableTypeDtRowNull');


-- table: [dbo].[DataTypeMap]
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'tinyint') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'tinyint', N'byte', N'SqlDbType.TinyInt', N'DbType.Byte', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallint') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallint', N'short', N'SqlDbType.SmallInt', N'DbType.Int16', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'int') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'int', N'int', N'SqlDbType.Int', N'DbType.Int32', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bigint') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bigint', N'long', N'SqlDbType.BigInt', N'DbType.Int64', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varchar') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varchar', N'string', N'SqlDbType.VarChar', N'DbType.AnsiString', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'char') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'char', N'string', N'SqlDbType.Char', N'DbType.AnsiStringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nvarchar') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nvarchar', N'string', N'SqlDbType.NVarChar', N'DbType.String', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'nchar') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'nchar', N'string', N'SqlDbType.NChar', N'DbType.StringFixedLength', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'date') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'date', N'DateOnly', N'SqlDbType.Date', N'DbType.Date', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'time') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'time', N'TimeOnly', N'SqlDbType.Time', N'DbType.Time', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime2') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime2', N'DateTime', N'SqlDbType.DateTime2', N'DbType.DateTime2', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetimeoffset') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetimeoffset', N'DateTimeOffset', N'SqlDbType.DateTimeOffset', N'DbType.DateTimeOffset', 0, 0, 0, 1);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smalldatetime') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smalldatetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'datetime') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'datetime', N'DateTime', N'SqlDbType.DateTime', N'DbType.DateTime', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'real') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'real', N'float', N'SqlDbType.Real', N'DbType.Single', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'float') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'float', N'double', N'SqlDbType.Float', N'DbType.Double', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'money') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'money', N'decimal', N'SqlDbType.Money', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'decimal') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'decimal', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'numeric') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'numeric', N'decimal', N'SqlDbType.Decimal', N'DbType.Decimal', 0, 0, 1, 1);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'smallmoney') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'smallmoney', N'decimal', N'SqlDbType.SmallMoney', N'DbType.Decimal', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'bit') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'bit', N'bool', N'SqlDbType.Bit', N'DbType.Boolean', 1, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'varbinary') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'varbinary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'binary') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'binary', N'byte[]', N'SqlDbType.VarBinary', N'DbType.Binary', 1, 1, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'uniqueidentifier') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'uniqueidentifier', N'Guid', N'SqlDbType.UniqueIdentifier', N'DbType.Guid', 0, 0, 0, 0);

IF NOT EXISTS (SELECT 1 FROM [dbo].[DataTypeMap] WHERE [LanguageId]=1 AND [SqlType]=N'sql_variant') 
INSERT INTO [dbo].[DataTypeMap] ([LanguageId], [SqlType], [NativeType], [SqlDbType], [DbType], [IsNullable], [SizeNeeded], [PrecisionNeeded], [ScaleNeeded]) 
VALUES (1, N'sql_variant', N'object', N'SqlDbType.Variant', N'DbType.Object', 1, 0, 0, 0);



-- Completion time: 2024-02-08T21:10:25.9416318+00:00

GO

DROP TABLE IF EXISTS #Template;
GO

CREATE TABLE #Template
(
    [Id] [smallint] IDENTITY(1,1) NOT NULL PRIMARY KEY,
    [LanguageId] [tinyint] NOT NULL,
    [TypeId] [tinyint] NOT NULL,
    [Template] [nvarchar](4000) NOT NULL,
    UNIQUE ([LanguageId], [TypeId])
);
GO

DECLARE @langId TINYINT = (SELECT [Id] FROM [Enum].[Language] WHERE [Name] = 'C#');

DECLARE @TT_START TINYINT = 1;
DECLARE @TT_END TINYINT = 2;
DECLARE @TT_ENUM_START TINYINT = 3;
DECLARE @TT_ENUM_END TINYINT = 4;
DECLARE @TT_ENUM_ENTRY TINYINT = 5;
DECLARE @TT_RESULT_TYPE_START TINYINT = 6;
DECLARE @TT_RESULT_TYPE_END TINYINT = 7;
DECLARE @TT_RESULT_TYPE_PROPERTY TINYINT = 8;
DECLARE @TT_STATIC_START TINYINT = 9;
DECLARE @TT_WRAPPER_START TINYINT = 10;
DECLARE @TT_WRAPPER_END TINYINT = 11;
DECLARE @TT_WRAPPER_PREP TINYINT = 12;
DECLARE @TT_WRAPPER_EXEC TINYINT = 13;
DECLARE @TT_WRAPPER_PARAM TINYINT = 14;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT TINYINT = 15;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT TINYINT = 16;
DECLARE @TT_WRAPPER_EXEC_RS TINYINT = 17;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_INPUT_OUTPUT TINYINT = 18;
DECLARE @TT_WRAPPER_PARAM_POST_EXEC TINYINT = 19;
DECLARE @TT_WRAPPER_START2 TINYINT = 20;
DECLARE @TT_WRAPPER_RETURN_PARAM TINYINT = 21;
DECLARE @TT_WRAPPER_END2 TINYINT = 22;
DECLARE @TT_WRAPPER_RETURN_PARAM_DEC TINYINT = 23;
DECLARE @TT_TABLE_TYPE_START TINYINT = 24;
DECLARE @TT_TABLE_TYPE_END TINYINT = 25;
DECLARE @TT_TABLE_TYPE_PROPERTY TINYINT = 26;
DECLARE @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE TINYINT = 27;
DECLARE @TT_TABLE_TYPE_DT_START TINYINT = 28;
DECLARE @TT_TABLE_TYPE_DT_END TINYINT = 29;
DECLARE @TT_TABLE_TYPE_DT_COLUMN TINYINT = 30;
DECLARE @TT_TABLE_TYPE_DT_ROWS_START TINYINT = 31;
DECLARE @TT_TABLE_TYPE_DT_ROWS_END TINYINT = 32;
DECLARE @TT_TABLE_TYPE_DT_ROW TINYINT = 33;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_ADD TINYINT = 34;
DECLARE @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN TINYINT = 35;
DECLARE @TT_TABLE_TYPE_DT_ROW_NULL TINYINT = 36;

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_START, 
N'// <auto-generated>
//     This code was generated by a tool.
//
//     Project name:    @{ProjectName}
//     Source database: @{Database}
//     Source server:   @{ServerName}
//     Source instance: @{InstanceName}
//     Timestamp:       @{Timestamp}
//     Tool name:       @{ToolName}
//     Tool version:    @{ToolVersion}
//     Tool URL:        @{ToolUrl}
//
//     Changes to this file may cause incorrect behavior 
//     and will be lost if the code is regenerated.
// </auto-generated>

using System.Data;
using System.Data.Common;
using Microsoft.Data.SqlClient;
using Dapper;

namespace @{NamespaceName}
{
    @{ClassAccess} partial class @{ClassName}
    {
        public string ConnectionString { get; set; }
        
        public @{ClassName}(string connectionString = null)
        {
            ConnectionString = connectionString;
        }

        protected virtual DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_STATIC_START, 
N'// <auto-generated>
//     This code was generated by a tool.
//
//     Project name:    @{ProjectName}
//     Source database: @{Database}
//     Source server:   @{ServerName}
//     Source instance: @{InstanceName}
//     Timestamp:       @{Timestamp}
//     Tool name:       @{ToolName}
//     Tool version:    @{ToolVersion}
//     Tool URL:        @{ToolUrl}
//
//     Changes to this file may cause incorrect behavior 
//     and will be lost if the code is regenerated.
// </auto-generated>

using System.Data;
using System.Data.Common;
using Microsoft.Data.SqlClient;
using Dapper;

namespace @{NamespaceName}
{
    @{ClassAccess} static partial class @{ClassName}
    {
        public static string ConnectionString { get; set; }
        
        private static DbConnection GetDbConnection()
        {
            return new SqlConnection(ConnectionString);
        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_END, 
N'
    }
}
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_START, 
N'
        // Source table: @{EnumSchema}.@{EnumTable}
        @{EnumAccess} enum @{EnumName}
        {');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_ENUM_ENTRY, N'            @{Name} = @{Value}@{Sep}');





INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_START, 
N'
        // Result type for a stored procedure: @{SpSchema}.@{SpName}
        @{ClassAccess} partial class @{ClassName}
        {');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_RESULT_TYPE_PROPERTY, N'            @{PropertyAccess} @{Type} @{Name} { get; set; }');




INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START, 
N'
        // Wrapper method for a stored procedure: @{SpSchema}.@{SpName}
        @{MethodAccess} async Task<@{TupleStart}
            @{ResultType}@{ResultVarNameTuple}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_START2, 
N'        @{TupleEnd}> @{WrapperName}Async(');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PREP, N'        )
        {
            @{ResultType} @{ResultVarName};
            var p = new DynamicParameters();
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC, N'            p.Add("@returnValue", dbType: DbType.Int32, direction: ParameterDirection.ReturnValue);
            
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();
                await connection.ExecuteAsync("@{SpSchema}.@{SpName}", p, commandType: CommandType.StoredProcedure);
                connection.Close();
            }
            @{ResultVarName} = p.Get<@{ResultType}>("@returnValue");
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_EXEC_RS, N'
            using (var connection = GetDbConnection())
            {
                await connection.OpenAsync();

                var queryResult = await connection.QueryAsync<@{ResultTypeSingle}>("@{SpSchema}.@{SpName}", p, commandType: CommandType.StoredProcedure);

                connection.Close();
                @{ResultVarName} = queryResult.ToList();
            }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END, 
N'            return @{TupleStart}
                @{ResultVarName}@{Sep}');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_END2, 
N'            @{TupleEnd};
        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM, N'            @{ParamOpt}@{Type} @{ParamName}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM, N'                @{ParamName}@{Sep}');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_RETURN_PARAM_DEC, N'            @{Type} @{ParamName}@{Sep}');



INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_INPUT, N'            p.Add("@{Name}", @{TypeCast}@{ParamName});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_OUTPUT, N'            p.Add("@{Name}", null, @{DbType}, ParameterDirection.Output, @{Size}, @{Precision}, @{Scale});');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_INPUT_OUTPUT, N'            p.Add("@{Name}", @{ParamName}, @{DbType}, ParameterDirection.InputOutput, @{Size}, @{Precision}, @{Scale});');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_PRE_EXEC_TABLE_TYPE, N'
            var @{DtName} = @{TableType}.ToDataTable(@{ParamName});			
			p.Add("@{Name}", @{DtName}.AsTableValuedParameter("@{TvpName}"));
			');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_WRAPPER_PARAM_POST_EXEC, N'            @{OutVarDecl}@{ParamName} = @{TypeCast}p.Get<@{Type}>("@{Name}");');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_START, 
N'
        // Table type: @{TtSchema}.@{TtName}
        @{ClassAccess} partial class @{ClassName}
        {');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_END, 
N'        }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_PROPERTY, N'            @{PropertyAccess} @{Type} @{Name} { get; set; }');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_START, 
N'
            public static DataTable ToDataTable(IEnumerable<@{ClassName}> records)        
            {
			    var table = new DataTable("@{TtSchema}.@{TtName}");
				DataColumn column;
				DataRow row;
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_END, 
N'				return table;
            }
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN, 
N'			    column = new DataColumn();
			    column.DataType = typeof(@{BaseType});
			    column.ColumnName = "@{ColumnName}";
				column.AllowDBNull = @{AllowNull};');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_MAX_LEN, 
N'				column.MaxLength = @{MaxLength};');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_COLUMN_ADD, 
N'			    table.Columns.Add(column);				
');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_START, 
N'			    foreach (var record in records)
			    {
				    row = table.NewRow();');


INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROWS_END, 
N'			        table.Rows.Add(row);  
			    }
');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW, 
N'			    row["@{ColumnName}"] = @{Cast}record.@{Name};');

INSERT INTO #Template
([LanguageId], [TypeId], [Template])
VALUES
(@langId, @TT_TABLE_TYPE_DT_ROW_NULL, 
N'			    row["@{ColumnName}"] = (object)(@{Cast}record.@{Name}) ?? DBNull.Value;');


GO



UPDATE xt
SET xt.[Template]=t.[Template]
FROM #Template t
JOIN [dbo].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId];

GO

INSERT INTO [dbo].[Template]
([LanguageId], [TypeId], [Template])
SELECT 
t.[LanguageId], t.[TypeId], t.[Template]
FROM #Template t
LEFT JOIN [dbo].[Template] xt ON t.[LanguageId]=xt.[LanguageId] AND  t.[TypeId]=xt.[TypeId]
WHERE xt.[Id] IS NULL;
GO

DROP TABLE IF EXISTS #Template;
GO

DECLARE @version VARCHAR(50) = '0.3';
DECLARE @description NVARCHAR(500) = N'Added support for table valued parameters.'

IF NOT EXISTS (SELECT 1 FROM [dbo].[Version] WHERE [Version]=@version)
BEGIN
	INSERT INTO [dbo].[Version] ([Version], [Description])
	VALUES (@version, @description);
END

GO

GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [dbo].[DataTypeMap] WITH CHECK CHECK CONSTRAINT [FK_DataTypeMap_Language];

ALTER TABLE [dbo].[Project] WITH CHECK CHECK CONSTRAINT [FK_Project_ClassAccess];

ALTER TABLE [dbo].[Project] WITH CHECK CHECK CONSTRAINT [FK_Project_Language];

ALTER TABLE [dbo].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_Language];

ALTER TABLE [dbo].[Template] WITH CHECK CHECK CONSTRAINT [FK_Template_TemplateType];


GO
PRINT N'Update complete.';


GO
